<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试使用jdbc工具类简化JDBC-新增开发]]></title>
    <url>%2F2018%2F04%2F25%2Fjdbc%E6%B5%8B%E8%AF%95%E6%96%B0%E5%A2%9E%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[方法说明此jdbc测试工具类是为了简化使用jdbc进行新增的方法，使用此方法可以避免使用uuid生成的主键，此举主要是为了如果在有一个同样数据库，里面两条数据的主键一致性问题。因为使用hibernate可以自动生成32位的uuid 代码如下：import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; import java.util.Properties; import java.util.Set; import org.apache.commons.lang3.StringUtils; import com.cloud.icenter.common.utils.DESUtil; import com.cloud.icenter.common.utils.JDBCUtil; import com.cloud.icenter.common.utils.JDBCUtil.DataBaseType; /** * 测试使用JDBCUtil工具类来简化JDBC开发 * @author ynxiea */ public class JdbcOperationUtil { static Properties pros = null; // 可以帮助读取和处理资源文件中的信息 static { // 加载JDBCUtil类的时候调用。注意这里的话，只会被加载一次。 pros = new Properties(); try{ //关键的代码 pros.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 对jdbc.properties 文件进行解密 String userName = pros.getProperty(&quot;jdbc.username&quot;); if (userName != null) { pros.setProperty(&quot;jdbc.username&quot;,DESUtil.decrypt(userName, DESUtil.key)); } String passWord = pros.getProperty(&quot;jdbc.password&quot;); if (passWord != null) { pros.setProperty(&quot;jdbc.password&quot;, DESUtil.decrypt(passWord, DESUtil.key)); } String url = pros.getProperty(&quot;jdbc.url&quot;); if (url != null) { pros.setProperty(&quot;jdbc.url&quot;, DESUtil.decrypt(url, DESUtil.key)); } String driver = pros.getProperty(&quot;jdbc.driver&quot;); if(driver != null){ pros.setProperty(&quot;jdbc.driver&quot;, DESUtil.decrypt(driver, DESUtil.key)); } String dialect = pros.getProperty(&quot;hibernate.dialect&quot;); if (dialect != null) { pros.setProperty(&quot;hibernate.dialect&quot;, DESUtil.decrypt(dialect, DESUtil.key)); } } catch(Exception e){ e.printStackTrace(); } } /** * 获取JDBC数据库连接信息 * @return * @throws Exception */ public static Connection getConnection() throws Exception { return JDBCUtil.getConnection(pros.getProperty(&quot;jdbc.url&quot;), pros.getProperty(&quot;jdbc.username&quot;), pros.getProperty(&quot;jdbc.password&quot;), DataBaseType.MYSQL); } /** * 保存数据 * @param tableName 表名称 * @param data 数据 * @throws Exception */ public static int saveData(String tableName, Map&lt;String, Object&gt; data) { Connection conn = null; PreparedStatement pst = null; try { if (!StringUtils.isEmpty(tableName) &amp;&amp; data != null &amp;&amp; data.size()&gt;0) { conn = getConnection(); StringBuilder sb = new StringBuilder(); sb.append(&quot; insert into &quot;); sb.append(tableName); sb.append(&quot;(&quot;); Set&lt;String&gt; sets = data.keySet(); int size = sets.size(); int count = 1; for (String key : sets) { if (count == size) { sb.append(key); } else { sb.append(key+&quot;,&quot;); } count++; } sb.append(&quot;)&quot;); sb.append(&quot; VALUES (&quot;); int count1 = 1; for (String key : sets) { if (count1 == size) { sb.append(&quot;?&quot;); } else { sb.append(&quot;?,&quot;); } count1++; } sb.append(&quot;)&quot;); //System.out.println(&quot;sql=&quot;+sb.toString()); pst = conn.prepareStatement(sb.toString()); int start = 1; for (String key : sets) { pst.setObject(start, data.get(key)); start++; } int res = pst.executeUpdate(); return res; } } catch (Exception e) { e.printStackTrace(); } finally { try { pst.close(); conn.close(); pst = null; conn = null; } catch (SQLException e) { e.printStackTrace(); } } return 0; } public static void main(String[] args) throws Exception { //System.out.println(getConnection()); String tableName = &quot;irsp_coding_org&quot;; Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); data.put(&quot;ID&quot;, &quot;8a90fa955d888e2f015d88bcd66f0008&quot;); data.put(&quot;ORG_ID&quot;, &quot;8a90fa955d888e2f015d88bcd66f9998&quot;); data.put(&quot;CODE_ID&quot;, &quot;8a90fa955d888e2f015d88bcd66f6668&quot;); saveData(tableName, data); } } 上面方法所用到的工具类如下：第一个为DESUtil,代码如下：import java.io.IOException; import java.security.SecureRandom; import javax.crypto.Cipher; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; public class DESUtil { private final static String DES = &quot;DES&quot;; public static String key=&quot;cc6b473b7ea2f23546d0361573b98b30&quot;; public static void main(String[] args) throws Exception { String data = &quot;jdbc:mysql://10.16.123.149:3306/irsp_xm?useUnicode=true&amp;characterEncoding=utf8&quot;; // String key = &quot;wang!@#$%&quot;; System.err.println(encrypt(data, key)); System.err.println(decrypt(encrypt(data, key), key)); } /** * Description 根据键值进行加密 * @param data * @param key 加密键byte数组 * @return * @throws Exception */ public static String encrypt(String data, String key) throws Exception { byte[] bt = encrypt(data.getBytes(&quot;UTF-8&quot;), key.getBytes(&quot;UTF-8&quot;)); String strs = new BASE64Encoder().encode(bt); return strs; } /** * Description 根据键值进行解密 * @param data * @param key 加密键byte数组 * @return * @throws IOException * @throws Exception */ public static String decrypt(String data, String key){ try { if (data == null) return null; BASE64Decoder decoder = new BASE64Decoder(); byte[] buf = decoder.decodeBuffer(data); byte[] bt = decrypt(buf,key.getBytes(&quot;UTF-8&quot;)); return new String(bt,&quot;UTF-8&quot;); } catch (Exception e) { return data; } } /** * Description 根据键值进行加密 * @param data * @param key 加密键byte数组 * @return * @throws Exception */ private static byte[] encrypt(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始密钥数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(DES); // 用密钥初始化Cipher对象 cipher.init(Cipher.ENCRYPT_MODE, securekey, sr); return cipher.doFinal(data); } /** * Description 根据键值进行解密 * @param data * @param key 加密键byte数组 * @return * @throws Exception */ private static byte[] decrypt(byte[] data, byte[] key) throws Exception { // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始密钥数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(DES); // 用密钥初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, sr); return cipher.doFinal(data); } } 第二个为JDBCUtils,代码如下： import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import org.springframework.util.StringUtils; import com.cloud.icenter.system.data.utils.DictConstans; /** * JDBC工具类 * @author byl * */ public class JDBCUtil { public JDBCUtil() { super(); } public static Connection getConnection(String url,String username,String password , DataBaseType dbType) throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException { Class.forName(dbType.getDriverName()); //设置超时时间，暂时解决错误密码等待时间 DriverManager.setLoginTimeout(1000); return DriverManager.getConnection(url, username, password); } public static Connection getConnection(String dbIp , String port , String dbName , String userName , String password , String instanceName , DataBaseType dbType) throws ClassNotFoundException, SQLException, InstantiationException, IllegalAccessException{ if(!StringUtil.isEmpty(dbIp) &amp;&amp; !StringUtil.isEmpty(userName) &amp;&amp; !StringUtil.isEmpty(password) &amp;&amp; dbType != null){ return getConnection(getJdbcConnectionUrl(dbIp, dbName, port, instanceName, dbType), userName, password, dbType); } return null; } public static void close(ResultSet rs, Statement st, Connection conn) throws SQLException { try { if (rs != null) { rs.close(); } }finally{ try { if(st!=null){ st.close(); } }finally{ if(conn!=null){ conn.close(); } } } } /** * jdbc url解析 * @param url * @return */ public static DataBaseObj parse(String url){ if(!StringUtil.isEmpty(url)){ DataBaseObj dbo = new DataBaseObj(); url = url.replace(&quot;jdbc:oracle:thin:@&quot;, &quot;&quot;); String[] params = url.split(&quot;:&quot;); dbo.setHost(params[0]); dbo.setPort(params[1]); dbo.setDbName(params[2]); return dbo; } return null; } /** * 将IP地址和databaseName根据数据库类型，转换成标准的连接URL * @param dbIp * @param dbName * @param dbType * @param * @return */ public static String getJdbcConnectionUrl(String dbIp , String dbName , String port , String instanceName , DataBaseType dbType){ if(StringUtils.hasText(dbName) &amp;&amp; StringUtils.hasText(port) &amp;&amp; StringUtils.hasText(dbIp) &amp;&amp; dbType != null){ if(DataBaseType.MYSQL.equals(dbType) || DictConstans.DB_TYPE_MYSQL.equals(dbType)){ //MYSQL return String.format(dbType.getDriverUrl(), dbIp , port , dbName); }else if(DataBaseType.ORACLE.equals(dbType) || DictConstans.DB_TYPE_ORACLE.equals(dbType)){ //Oracle return String.format(dbType.getDriverUrl(), dbIp , port , dbName); }else if(DataBaseType.SQLSERVER.equals(dbType) || DictConstans.DB_TYPE_SQLSERVER.equals(dbType)){ //Sql Server if(StringUtils.hasText(instanceName)){ return String.format(dbType.getDriverUrl(), dbIp , port , instanceName , dbName); } }else if(DataBaseType.DM.equals(dbType) || DictConstans.DB_TYPE_DM.equals(dbType)){ //达梦数据库 return String.format(dbType.getDriverUrl(), dbIp , port , dbName); } } return null; } /** * 根据dbtype获取相应数据库的驱动类型 * @param dbType * @return */ public static DataBaseType getDataBaseTypeByDbType(String dbType) { DataBaseType dataType = null; if(DictConstans.DB_TYPE_MYSQL.equals(dbType)){ dataType = DataBaseType.MYSQL; }else if(DictConstans.DB_TYPE_ORACLE.equals(dbType)){ dataType = DataBaseType.ORACLE; }else if(DictConstans.DB_TYPE_SQLSERVER.equals(dbType)){ dataType = DataBaseType.SQLSERVER; }else if(DictConstans.DB_TYPE_DM.equals(dbType)){ dataType = DataBaseType.DM; } return dataType; } public enum DataBaseType { MYSQL(&quot;com.mysql.jdbc.Driver&quot;, &quot;jdbc:mysql://%s:%s/%s?useUnicode=true&amp;characterEncoding=utf8&quot; , &quot;jdbc:mysql://%s:%s/&quot;) , ORACLE(&quot;oracle.jdbc.driver.OracleDriver&quot;, &quot;jdbc:oracle:thin:@//%s:%s/%s&quot; , &quot;&quot;), DM(&quot;dm.jdbc.driver.DmDriver&quot;, &quot;jdbc:dm://%s:%s/%s&quot; , &quot;&quot;), SQLSERVER(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; , &quot;jdbc:sqlserver://%s:%s;instanceName=%s;DatabaseName=%s&quot; , &quot;&quot;); private String driverName; private String driverUrl; private String noDbNameUrl; DataBaseType(String driverName , String driverUrl , String noDbNameUrl) { this.driverName = driverName; this.driverUrl = driverUrl; this.noDbNameUrl = noDbNameUrl; } public String getDriverName() { return driverName; } public String getDriverUrl() { return driverUrl; } public String getNoDbNameUrl() { return noDbNameUrl; } } } 需要注意的是： public static int saveData(String tableName, Map data) { tableName为数据库表名 Map 中key为数据库表字段名，value为对应的值。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用线程监听队列]]></title>
    <url>%2F2018%2F04%2F25%2F%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[定义一个队列，把数据放到队列中，代码如下：import java.util.HashMap; import java.util.Map; import java.util.concurrent.ConcurrentLinkedQueue; import com.cloud.icenter.common.utils.SystemConfig; /** * 级联模块所有的接口回调，都要先将回调数据发送到队列当中 * 同事线程监控该队列，进场接口回调处理 * @author ynxiea * */ public class CallbackUtil { //组织机构回调 public static final String CALLBACK_ORGAN = &quot;organCallback&quot;; //资源分类回调 public static final String CALLBACK_CATEGORY = &quot;categoryCallback&quot;; //资源目录回调 public static final String CALLBACK_CATALOG = &quot;catalogCallback&quot;; //服务发布回调 public static final String CALLBACK_SERVICE = &quot;serviceCallback&quot;; //服务申请回调 public static final String CALLBACK_APPLY = &quot;applyCallback&quot;; //组织机构回调:类型=1 public static final String CALLBACK_TYPE_01 = &quot;1&quot;; //资源分类回调:类型=2 public static final String CALLBACK_TYPE_02 = &quot;2&quot;; //资源目录回调:类型=3 public static final String CALLBACK_TYPE_03 = &quot;3&quot;; //服务发布回调:类型=4 public static final String CALLBACK_TYPE_04 = &quot;4&quot;; //服务申请回调:类型=5 public static final String CALLBACK_TYPE_05 = &quot;5&quot;; public static ConcurrentLinkedQueue&lt;Map&lt;String, String&gt;&gt; queue = new ConcurrentLinkedQueue&lt;Map&lt;String, String&gt;&gt;(); //新增数据到队列当中 public static void addQueue(Map&lt;String, String&gt; jsonMap) { //级联模块：1 = 代表湖北省，省市级联， 2 = 其他地市，不需要地市级联 String cascadeFlag = SystemConfig.getProperty(&quot;cascade.data&quot;); if (cascadeFlag.equals(&quot;1&quot;)) { queue.add(jsonMap); } } //获取队列大小 public static int getQueueSize() { return queue.size(); } //获取队列的数据 public static Map&lt;String, String&gt; pullData() { if (queue.size() &gt; 0) { return queue.poll(); } return null; } public static void main(String[] args) { Map&lt;String, String&gt; jsonMap1 = new HashMap&lt;String, String&gt;(); jsonMap1.put(CALLBACK_ORGAN, &quot;json&quot;); Map&lt;String, String&gt; jsonMap2 = new HashMap&lt;String, String&gt;(); jsonMap2.put(CALLBACK_CATEGORY, &quot;categoryCallback&quot;); Map&lt;String, String&gt; jsonMap3 = new HashMap&lt;String, String&gt;(); jsonMap3.put(CALLBACK_CATALOG, &quot;catalogCallback&quot;); Map&lt;String, String&gt; jsonMap4 = new HashMap&lt;String, String&gt;(); jsonMap4.put(CALLBACK_SERVICE, &quot;serviceCallback&quot;); Map&lt;String, String&gt; jsonMap5 = new HashMap&lt;String, String&gt;(); jsonMap5.put(CALLBACK_APPLY, &quot;applyCallback&quot;); addQueue(jsonMap1); addQueue(jsonMap2); addQueue(jsonMap3); addQueue(jsonMap4); addQueue(jsonMap5); System.out.println(&quot;队列大小：&quot;+getQueueSize()); for (int i=0;i&lt;10;i++){ System.out.println(pullData()); System.out.println(getQueueSize()); } } } 使用线程，执行队列任务/** * 常驻线程：执行队列任务 * @author ynxiea * */ public class CallbackThread extends Thread { @Override public void run() { while (true) { int size = CallbackUtil.getQueueSize(); if (size &gt; 0) { CallbackOperation.doExecute(); } else { try { Thread.sleep(5 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 接口回调处理接口public class CallbackOperation { private static CallbackService callbackService; static { callbackService = SpringUtil.getBean(CallbackService.class); } //执行回调处理 public static void doExecute() { int size = CallbackUtil.getQueueSize(); for (int i=0;i&lt;size;i++) { Map&lt;String, String&gt; jsonMap = CallbackUtil.pullData(); if (jsonMap != null &amp;&amp; !jsonMap.isEmpty()) { Set&lt;String&gt; sets = jsonMap.keySet(); for (String key : sets) { if (CallbackUtil.CALLBACK_ORGAN.equals(key)) { //组织机构回调 organCallback(jsonMap.get(key)); } else if (CallbackUtil.CALLBACK_CATEGORY.equals(key)) { //资源分类回调 categoryCallback(jsonMap.get(key)); } else if (CallbackUtil.CALLBACK_CATALOG.equals(key)) { //资源目录回调 catalogCallback(jsonMap.get(key)); } else if (CallbackUtil.CALLBACK_SERVICE.equals(key)) { //服务发布回调 serviceCallback(jsonMap.get(key)); } else if (CallbackUtil.CALLBACK_APPLY.equals(key)) { //服务申请回调 applyCallback(jsonMap.get(key)); } else { //其他回调接口，待处理 } } } } } //发送http请求 private static void sendHttpData(List&lt;Callback&gt; list, String json) { if (list != null &amp;&amp; list.size()&gt;0) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;); //发送数据：先组装成map对象 Map&lt;String, String&gt; jsonData = new HashMap&lt;String, String&gt;(); //时间戳 jsonData.put(&quot;timestamp&quot;, sdf.format(new Date())); //sign生成待定 String sign = SignGeneration.generationSign(params, sk); jsonData.put(&quot;sign&quot;, &quot;&quot;); //请求数据 jsonData.put(&quot;data&quot;, json); for (Callback c: list) { Map&lt;String, String&gt; mapParams = null; //接口请求参数 String requestParams = c.getRequestParams(); if (!StringUtil.isEmpty(requestParams)) { mapParams = CascadeJsonUtil.toObject(requestParams, Map.class); } if (mapParams!= null &amp;&amp; !mapParams.isEmpty()) { jsonData.putAll(mapParams); } String sendJson = CascadeJsonUtil.toJson(jsonData); try { Map&lt;String,Object&gt; result = CascadeHttpUtil.sendPost(c.getUrlAddress(), sendJson); System.out.println(result); //记录日志 } catch (Exception e) { e.printStackTrace(); } } } } //组织机构回调 private static void organCallback(String json) { List&lt;Callback&gt; list = callbackService.queryByType(CallbackUtil.CALLBACK_TYPE_01); sendHttpData(list, json); } //资源分类回调 private static void categoryCallback(String json) { List&lt;Callback&gt; list = callbackService.queryByType(CallbackUtil.CALLBACK_TYPE_02); List&lt;Callback&gt; result = new ArrayList&lt;Callback&gt;(); Map&lt;String, Object&gt; jsonData = CascadeJsonUtil.toObject(json, Map.class); //判断传递参数是否存在：organId,如果存在，代表地市的资源分类变化，回调时过滤该组织机构 if (jsonData.containsKey(&quot;organId&quot;)) { String organId = String.valueOf(jsonData.get(&quot;organId&quot;)); for(Callback c : list) { if (!c.getOrganId().equals(organId)) { result.add(c); } } } else { result.addAll(list); } sendHttpData(result, json); } //资源目录回调 private static void catalogCallback(String json) { List&lt;Callback&gt; list = callbackService.queryByType(CallbackUtil.CALLBACK_TYPE_03); List&lt;Callback&gt; result = new ArrayList&lt;Callback&gt;(); Map&lt;String, Object&gt; jsonData = CascadeJsonUtil.toObject(json, Map.class); //判断传递参数是否存在：organId,如果存在，代表地市的资源目录变化，回调时过滤该组织机构 if (jsonData.containsKey(&quot;organId&quot;)) { String organId = String.valueOf(jsonData.get(&quot;organId&quot;)); for(Callback c : list) { if (!c.getOrganId().equals(organId)) { result.add(c); } } } else { result.addAll(list); } sendHttpData(result, json); } //服务发布回调 private static void serviceCallback(String json) { List&lt;Callback&gt; list = callbackService.queryByType(CallbackUtil.CALLBACK_TYPE_04); sendHttpData(list, json); } //服务申请回调 private static void applyCallback(String json) { List&lt;Callback&gt; list = callbackService.queryByType(CallbackUtil.CALLBACK_TYPE_05); sendHttpData(list, json); } }]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口请求示例]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[先定义Http请求的方式 定义一个工具类，工具类代码如下： package com.nan.util; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLDecoder; import java.net.URLEncoder; import java.util.List; import java.util.Map; import java.util.Set; //import org.apache.log4j.Logger; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class CascadeHttpUtil { // protected static Logger logger = Logger.getLogger(CascadeHttpUtil.class); /** * 功能: post形式发送数据 * @param urlPath 对方地址 * @param json 要传送的数据 * @return * @throws Exception * */ public static Map&lt;String,Object&gt; sendPost(String url, String json){ Map&lt;String,Object&gt; mresult = null; OutputStreamWriter out = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try { URL realUrl = new URL(url); HttpURLConnection conn = (HttpURLConnection) realUrl.openConnection(); // 打开和URL之间的连接 // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); conn.setRequestMethod(&quot;POST&quot;);// POST方法 // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;,&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); //conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); conn.connect(); // 获取URLConnection对象对应的输出流 out = new OutputStreamWriter(conn.getOutputStream(), &quot;UTF-8&quot;); // 发送请求参数 out.write(URLEncoder.encode(json, &quot;UTF-8&quot;)); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result.append(line); } //获取返回数据 String jsonData = URLDecoder.decode(result.toString(), &quot;UTF-8&quot;); //返回结果 mresult = JSON.parseObject(jsonData); } catch (Exception e) { mresult = CodeResult.makeMap(CodeResult._codeResult200, e.getMessage()); e.printStackTrace(); } //使用finally块来关闭输出流、输入流 finally{ try{ if(out!=null){ out.close(); } if(in!=null){ in.close(); } } catch(IOException ex){ mresult = CodeResult.makeMap(CodeResult._codeResult200, ex.getMessage()); ex.printStackTrace(); } } return mresult; } /** * 向指定URL发送GET方法的请求 * @param url 发送请求的URL * @param params 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return URL 所代表远程资源的响应结果 */ public static Map&lt;String,Object&gt; sendGet(String url, String params) { Map&lt;String,Object&gt; mresult = CodeResult.makeMap(CodeResult.codeResult200, &quot;请求成功&quot;); String result = &quot;&quot;; BufferedReader in = null; try { String urlNameString = url + &quot;?&quot; + params; URL realUrl = new URL(urlNameString); // 打开和URL之间的连接 HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection(); // 设置通用的请求属性 connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); connection.setRequestProperty(&quot;user-agent&quot;,&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); // 建立实际的连接 connection.connect(); // 获取所有响应头字段 //Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields(); // 定义 BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(connection.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } mresult.put(&quot;data&quot;, result); } catch (Exception e) { mresult.put(&quot;code&quot;, CodeResult._codeResult200); mresult.put(&quot;msg&quot;, e.toString()); e.printStackTrace(); } // 使用finally块来关闭输入流 finally { try { if (in != null) { in.close(); } } catch (Exception e2) { mresult.put(&quot;code&quot;, CodeResult._codeResult200); mresult.put(&quot;msg&quot;, e2.toString()); e2.printStackTrace(); } } return mresult; } /** * 向指定URL发送GET方法的请求 * @param url 发送请求的URL * @param param 请求参数，Map 请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return URL 所代表远程资源的响应结果 */ public static Map&lt;String,Object&gt; sendGetMap(String url, Map&lt;String, Object&gt; param) { Map&lt;String,Object&gt; mresult = CodeResult.makeMap(CodeResult.codeResult200, &quot;请求成功&quot;); String result = &quot;&quot;; BufferedReader in = null; StringBuilder sb = new StringBuilder(); try { String requestParams = &quot;&quot;; Set&lt;String&gt; keySet = param.keySet(); int i=0; for (String k : keySet) { if (i==keySet.size()-1) { boolean chinese = StringUtil.isContainChinese(String.valueOf(param.get(k))); if(chinese){ requestParams+=k+&quot;=&quot;+URLEncoder.encode(String.valueOf(param.get(k)), &quot;utf-8&quot;); }else{ requestParams+=k+&quot;=&quot;+param.get(k); } } else { boolean chinese = StringUtil.isContainChinese(String.valueOf(param.get(k))); if(chinese){ requestParams+=k+&quot;=&quot;+URLEncoder.encode(String.valueOf(param.get(k)), &quot;utf-8&quot;)+&quot;&amp;&quot;; }else{ requestParams+=k+&quot;=&quot;+param.get(k)+&quot;&amp;&quot;; } } i++; } String urlNameString =null; if(url.contains(&quot;?&quot;)){ urlNameString = url + &quot;&amp;&quot; + requestParams; }else{ urlNameString = url + &quot;?&quot; + requestParams; } URL realUrl = new URL(urlNameString); // 打开和URL之间的连接 HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection(); // 设置通用的请求属性 connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); connection.setRequestProperty(&quot;user-agent&quot;,&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;); // 建立实际的连接 connection.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields(); // 定义 BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(connection.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } mresult.put(&quot;data&quot;, result); } catch (Exception e) { mresult.put(&quot;code&quot;, CodeResult._codeResult200); mresult.put(&quot;msg&quot;, e.toString()); e.printStackTrace(); } // 使用finally块来关闭输入流 finally { try { if (in != null) { in.close(); } } catch (Exception e2) { mresult.put(&quot;code&quot;, CodeResult._codeResult200); mresult.put(&quot;msg&quot;, e2.toString()); e2.printStackTrace(); } } return mresult; } /* * 功能: postBody形式发送数据 * @param urlPath 对方地址 * @param json 要传送的数据 * @return * @throws Exception * */ public static Map&lt;String,Object&gt; sendJsonData(String urlPath, String json) throws Exception{ Map&lt;String,Object&gt; mresult = CodeResult.makeMap(CodeResult.codeResult200, &quot;请求成功&quot;); // request URL url = new URL(urlPath); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 设置doOutput属性为true表示将使用此urlConnection写入数据 urlConnection.setDoOutput(true); urlConnection.setDoInput(true); // 定义待写入数据的内容类型，我们设置为application/x-www-form-urlencoded类型 urlConnection.setRequestProperty(&quot;content-type&quot;,&quot;application/text&quot;); // 得到请求的输出流对象 OutputStreamWriter out = new OutputStreamWriter(urlConnection.getOutputStream()); // 把数据写入请求的Body out.write(URLEncoder.encode(json, &quot;UTF-8&quot;));//编码 out.flush(); out.close(); /* * 得到响应对象 * @param urlConnection * @return 响应对象 * @throws IOException */ InputStream in = urlConnection.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(in,&quot;UTF-8&quot;)); StringBuffer temp = new StringBuffer(); String line = bufferedReader.readLine(); while (line != null) { temp.append(line).append(&quot;\r\n&quot;); line = bufferedReader.readLine(); } bufferedReader.close(); //返回的json对象 JSONObject jsonObj = JSONObject.parseObject(temp.toString()); if(CodeResult.codeResult200.equals(jsonObj.getString(&quot;code&quot;))){ mresult = CodeResult.makeMap(CodeResult.codeResult200,&quot;调用成功&quot;,&quot;UTF-8&quot;); }else{ mresult = CodeResult.makeMap(jsonObj.getString(&quot;code&quot;),jsonObj.getString(&quot;message&quot;)); } return mresult; } //将map型转为请求参数型 public static String urlencode(Map&lt;String,Object&gt; data) { StringBuilder sb = new StringBuilder(); for (Map.Entry i : data.entrySet()) { try { sb.append(i.getKey()).append(&quot;=&quot;).append(URLEncoder.encode(i.getValue()+&quot;&quot;,&quot;UTF-8&quot;)).append(&quot;&amp;&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } return sb.toString(); } } 返回一个结果参数类代码如下： import java.util.LinkedHashMap; import java.util.Map; public class CodeResult { public static final String _codeResult200 = &quot;-200&quot;;//操作成功 public static final String codeResult200 = &quot;200&quot;;// 请求成功 //下为通用状态--开始 public static final String _codeResult10 = &quot;-10&quot;;//数据签名不存在 public static final String _codeResult11 = &quot;-11&quot;;//无效的数据签名 public static final String _codeResult20 = &quot;-20&quot;;//时间戳不存在 public static final String _codeResult21 = &quot;-21&quot;;//无效的时间戳 public static final String _codeResult30 = &quot;-30&quot;;//无效的数据返回格式 public static final String _codeResult40 = &quot;-40&quot;;//访问的服务不存在 public static final String _codeResult50 = &quot;-50&quot;;//用户不存在 public static final String _codeResult60 = &quot;-60&quot;;//无效的签名方式 public static final String _codeResult70 = &quot;-70&quot;;//用户没有权限访问服务 public static final String _codeResult80 = &quot;-80&quot;;//系统错误 public static final String _codeResult90 = &quot;-90&quot;;//恶意访问 //结束 public static final String codeResult100 = &quot;-100&quot;; //参数异常 public static final String codeResult110 = &quot;-110&quot;; //AK不存在 public static final String codeResult120 = &quot;-120&quot;; //timestamp超时 public static final String codeResult130 = &quot;-130&quot;; //服务已停用 public static final String codeResult140 = &quot;-140&quot;;// 服务未申请 public static final String codeResult150 = &quot;-150&quot;;// 服务申请时间失效 public static final String codeResult160 = &quot;-160&quot;;// 服务申请权限已回收 public static final String codeResult170 = &quot;-170&quot;;// appId非法或者未授权 public static final String codeResult180 = &quot;-180&quot;;//代理接口错误类型 // public static final String _codeResult10 = &quot;-10&quot;;// 错误的请求KEY // public static final String _codeResult20 = &quot;-20&quot;;// KEY过期 // public static final String _codeResult30 = &quot;-30&quot;;// 系统内部异常 // public static final String _codeResult40 = &quot;-40&quot;;// 接口维护 // public static final String _codeResult50 = &quot;-50&quot;;// 接口停用 // public static final String _codeResult60 = &quot;-60&quot;;// 用户名错误 // public static final String _codeResult70 = &quot;-70&quot;;// 无权限访问 public static Map&lt;String,Object&gt; makeMap(String code, String msg,Object data) { Map&lt;String,Object&gt; m = new LinkedHashMap&lt;String,Object&gt;(); m.put(&quot;code&quot;,code); m.put(&quot;msg&quot;,msg); m.put(&quot;data&quot;,data); return m; } public static Map&lt;String,Object&gt; makeMap(String code, String msg) { Map&lt;String,Object&gt; m = new LinkedHashMap&lt;String,Object&gt;(); m.put(&quot;code&quot;,code); m.put(&quot;msg&quot;,msg); return m; } public static Map&lt;String,Object&gt; makeMap() { Map&lt;String,Object&gt; m = new LinkedHashMap&lt;String,Object&gt;(); m.put(&quot;code&quot;,codeResult200); m.put(&quot;msg&quot;,&quot;请求成功&quot;); return m; } public static Map&lt;String,Object&gt; makeMap(Map&lt;String,Object&gt; result, String msg) { result.put(&quot;code&quot;,_codeResult200); result.put(&quot;msg&quot;, msg); return result; } } 请求方法代码示例如下：public static void getAllOrgan() { String url = &quot;http://localhost:8080/irsp/cascade/catalog/query&quot;; Map&lt;String, Object&gt; mapData = new HashMap&lt;String, Object&gt;(); mapData.put(&quot;ak&quot;, &quot;ac8999bc1409448baf180838bbcb63e6&quot;); //ak mapData.put(&quot;codeId&quot;, &quot;23f56ca568bc4435b30e3f41e9ac64ba&quot;); mapData.put(&quot;pageIndex&quot;, &quot;1&quot;); mapData.put(&quot;pageSize&quot;, &quot;1&quot;); String json = JSON.toJSONString(mapData); Map&lt;String,Object&gt; result = CascadeHttpUtil.sendPost(url, json); System.out.println(result); } 接口代码如下所示：这个代码是在irsp项目里面，项目端口号是8080，请求的参数方法irsp/cascade/catalog/query /** * 获取全部组织机构 * @return */ @RequestMapping(value=&quot;/getAllOrgan&quot;, method=RequestMethod.POST) @ResponseBody public ResponseEntity&lt;Map&lt;String,Object&gt;&gt; getAllOrgan(@RequestBody String json) { Map&lt;String, Object&gt; result = CodeResult.makeMap(); String resultJson = null; String org = null; try { String jsonData = URLDecoder.decode(json, &quot;UTF-8&quot;); Map&lt;String, ?&gt; mapParams = CascadeJsonUtil.json2Map(jsonData); String ak = mapParams.get(&quot;ak&quot;).toString(); String codeId = mapParams.get(&quot;codeId&quot;).toString(); String pageIndex = mapParams.get(&quot;pageIndex&quot;).toString(); resultJson = JSONObject.toJson(result); org = URLEncode.encode(resultJson,&quot;UTF-8&quot;); System.out.println(mapParams); } catch (Exception e) { CodeResult.makeMap(result, e.getMessage()); e.printStackTrace(); } return org; }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端分页工具类]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%90%8E%E7%AB%AF%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[后端分页实现作下面的分页查询 后台代码如下：/** * 查询 */ @RequestMapping(method = RequestMethod.POST, value = &quot;/query&quot;) public void query(Database db) { DetachedCriteria criteria=getPagination().getCriteria(); if(!StringUtils.isEmpty(db.getInstanceName())) { criteria.add(Restrictions.like(&quot;database_name&quot;,db.getInstanceName().trim(),MatchMode.ANYWHERE)); } if(!StringUtils.isEmpty(db.getIsConnect())) { criteria.add(Restrictions.like(&quot;isConnect&quot;,db.getIsConnect().trim(),MatchMode.ANYWHERE)); } databaseService.find(getPagination()); printJson(getPagination()); } getPagination代码如下：import org.apache.commons.beanutils.BeanUtils; import org.springframework.core.ResolvableType; import com.cloud.icenter.common.utils.Pagination; public abstract class ModelAction&lt;T&gt; extends BaseAction { private Class&lt;T&gt; clazz; public ModelAction() { ResolvableType resolvableType = ResolvableType.forClass(getClass()); this.clazz=(Class&lt;T&gt;) resolvableType.getSuperType().getGeneric(0).resolve(); } /** * 获取页号 * @return */ public int getPage() { return getIntParameter(&quot;page&quot;, 1); } /** * 获取每页查询多少行 * @return */ public int getPageSize() { return getIntParameter(&quot;rows&quot;, Pagination.DEFAULT_PAGE_SIZE); } /** * 获取分页器 * @return */ public Pagination&lt;T&gt; getPagination() { Pagination&lt;T&gt; pagin=(Pagination&lt;T&gt;) getAttribute(&quot;pagin&quot;); if(pagin==null) { pagin=new Pagination&lt;T&gt;(getPage(),getPageSize()); pagin.buildCriteria(clazz); setAttribute(&quot;pagin&quot;, pagin); } return pagin; } /** * 获取分页器 * @return */ public &lt;E&gt; Pagination&lt;E&gt; newPagination(Class&lt;E&gt; e) { Pagination&lt;E&gt; pagin=new Pagination&lt;E&gt;(getPage(),getPageSize()); pagin.buildCriteria(e); return pagin; } public T getModel() { T model=(T) getAttribute(&quot;model&quot;); if(model==null) { try { model = clazz.newInstance(); BeanUtils.populate(model, getRequest().getParameterMap()); setAttribute(&quot;model&quot;, model); } catch (Exception e) { throw new RuntimeException(&quot;获取模型对象失败!&quot;, e); } } return model; } /** * 快速获取id参数 * @return */ protected String getId() { return getParameter(&quot;id&quot;); } } Pagination代码如下：/** * 分页器 * 页号从1开始,page==1就是第一页 * 行号从0开始 * @author zhangle */ public class Pagination&lt;T&gt; { public static final int DEFAULT_PAGE_SIZE=20; //默认分页行数 private int page; //当前页号,从1开始 private int pageSize; //每页多少行 private long totalCount; //总共有多少行 private List&lt;T&gt; dataList = new ArrayList&lt;T&gt;(); //数据列表 private DetachedCriteria criteria; //查询条件 public Pagination(int page) { this(page,DEFAULT_PAGE_SIZE); } public Pagination(int page,int pageSize) { this.page=page; this.pageSize=pageSize; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } public int getPageSize() { return pageSize; } public void setPageSize(int pageSize) { this.pageSize = pageSize; } public long getTotalCount() { return totalCount; } public void setTotalCount(long totalCount) { this.totalCount = totalCount; } public List&lt;T&gt; getDataList() { return dataList; } public void setDataList(List&lt;T&gt; dataList) { this.dataList = dataList; } /** * 获得首页页号 * @return */ public int getFirstPage() { return 1; } /** * 获得上一页页号 * @return */ public int getPrevPage() { return page&lt;=getFirstPage()?getFirstPage():page-1; } /** * 获得下一页页号 * @return */ public int getNextPage() { return page&gt;=getLastPage()?getLastPage():page+1; } /** * 获得最后一页页号 * @return */ public int getLastPage() { return ((int)Math.ceil(((double)totalCount)/((double)pageSize))); } /** * 判断是否第一页 * @return */ public boolean getIsFirstPage() { return page&lt;=getFirstPage(); } /** * 判断是否最后一页 * @return */ public boolean getIsLastPage() { return page&gt;=getLastPage(); } /** * 获取当前页的起始行号 * @return */ public int getStartResult() { return (page-1)*pageSize; } /** * 获取当前页的结束行号 * @return */ public long getEndResult() { int endResult=page*pageSize; if(endResult&gt;=totalCount) return totalCount; return endResult; } /** * 获取总共多少页 * @return */ public int getPageCount() { return getLastPage(); } /** * 获取查询条件对象 * @return */ public DetachedCriteria getCriteria() { return criteria; } /** * 设置查询条件对象 * @param criteria */ public void setCriteria(DetachedCriteria criteria) { this.criteria = criteria; } /** * 构造一个查询条件对象,并返回 * @param clazz * @return */ public DetachedCriteria buildCriteria(Class&lt;T&gt; clazz) { criteria=DetachedCriteria.forClass(clazz); return criteria; } } 分页工具类另一种写法/** * @description 自定义分页 * @author wangbin * @date 2015/12/22 * */ public class PagingUtil { public static final int MAX_PAGE_SIZE = 50;// 每页最大记录数限制 private int page = 1;// 当前页 private int pages = 0;// 总页数 private int rows = 15;// 每页记录数 private int total = 0;// 总记录数 private int pageStart;// 分页开始数 private List&lt;Object&gt; list;// 数据List public int getPage() { return page; } public void setPage(int page) { if (page &lt; 1) { page = 1; } this.page = page; } public int getPages() { pages = this.getTotal() / this.getRows(); if (this.getTotal() % this.getRows() &gt; 0) { pages++; } return pages; } public void setPages(int pages) { this.pages = pages; } public int getRows() { return rows; } public void setRows(int rows) { if (rows &lt; 1) { rows = 1; } else if (rows &gt; MAX_PAGE_SIZE) { rows = MAX_PAGE_SIZE; } this.rows = rows; } public int getTotal() { return total; } public void setTotal(int total) { this.total = total; } public int getPageStart() { return (page - 1) * rows; } public void setPageStart(int pageStart) { this.pageStart = pageStart; } public List&lt;Object&gt; getList() { return list; } public void setList(List&lt;Object&gt; list) { this.list = list; } /** * * @param pageNo 当前页码 * @param pageSize 页数 * @param list 所有集合 * @return * @throws Exception */ public static List&lt;?&gt; page(int pageNo, int pageSize, List&lt;?&gt; list) throws Exception { List&lt;Object&gt; result = new ArrayList&lt;Object&gt;(); if (list != null &amp;&amp; list.size() &gt; 0) { int allCount = list.size(); int pageCount = (allCount + pageSize - 1) / pageSize; if (pageNo &gt;= pageCount) { pageNo = pageCount; } int start = (pageNo - 1) * pageSize; int end = pageNo * pageSize; if (end &gt;= allCount) { end = allCount; } for (int i = start; i &lt; end; i++) { result.add(list.get(i)); } } return result; } }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯js分页]]></title>
    <url>%2F2018%2F03%2F18%2F%E7%BA%AFjs%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[纯js分页实质是数据行全部加载，通过是否显示属性完成分页功能 加载所有的数据，代码如下： //查询结果数据表格显示 function addTable(district,data,queryType){ //移除页面中默认的ul $(&quot;#info-shool ul&quot;).remove(); var str = &apos;&lt;ul&gt;&apos; for(var i=0;i&lt;data.length;i++){ str = str +&apos;&lt;li&gt;&apos;+&apos;&lt;div class=&quot;tipNum&quot;&gt;&apos;+data[i].count+&apos;&lt;/div&gt;&apos;+&apos;&lt;p class=&quot;fl num num1&quot;&gt;&apos;+(i+1)+&apos;&lt;/p&gt;&apos;+ &apos;&lt;div class=&quot;fl list&quot;&gt;&apos;+&apos;&lt;p class=&quot;list-txt&quot;&gt;&apos;+data[i].street+&apos;&lt;/p&gt;&apos;+&apos;&lt;p class=&quot;min-txt&quot;&gt;&apos;+data[i].street+&apos;&lt;/p&gt;&apos;+ &apos;&lt;/div&gt;&apos;+&apos;&lt;/li&gt;&apos; } str = str +&apos;&lt;/ul&gt;&apos;; $(&quot;#info-shool&quot;).append(str); goPage(1);//调用分页的函数，默认显示第一页 } 分页代码如下：//分页设置数据，含rows,total function goPage(pno){ var num = $(&quot;#info-shool&quot;).find(&quot;li&quot;).length;//所有li的统计(所有记录数) console.log(num); var totalPage = 0;//总页数 var pageSize = 15;//每页显示行数 //总共分几页 if(num/pageSize &gt; parseInt(num/pageSize)){ totalPage=parseInt(num/pageSize)+1; }else{ totalPage=parseInt(num/pageSize); } var currentPage = pno;//当前页数 var startRow = (currentPage - 1) * pageSize+1;//开始显示的行 31 var endRow = currentPage * pageSize;//结束显示的行 40 endRow = (endRow &gt; num)? num : endRow; //40 console.log(endRow); //遍历显示数据实现分页 for(var i=1;i&lt;(num+1);i++){ var irow = $(&quot;#info-shool&quot;).find(&quot;li&quot;).eq(i-1); if(i&gt;=startRow &amp;&amp; i&lt;=endRow){ $(irow).css(&quot;display&quot;,&quot;block&quot;);//根据条数来显示 }else{ $(irow).css(&quot;display&quot;,&quot;none&quot;);//隐藏所有的 } } var pageEnd = document.getElementById(&quot;pageEnd&quot;); var tempStr=&apos;&apos; //.bind(&quot;click&quot;,{&quot;newPage&quot;:pageIndex},function(event){ // goPage((pageIndex-1)*pageSize+1,(pageIndex-1)*pageSize+pageSize); // }).appendTo(&apos;#pages&apos;); //上一页 if(currentPage&gt;1){ tempStr += &quot;&lt;div class=&apos;one o-left&apos; onClick=\&quot;goPage(&quot;+(currentPage-1)+&quot;)\&quot;&gt;&lt;/div&gt;&quot; }else{ tempStr += &quot;&lt;div class=&apos;one o-left&apos;&gt;&lt;/div&gt;&quot;; } //模仿百度的分页 var b;//开始 var e;//结束 //当总页数 &lt;=10时候，说明一共不超过10页，让begin=1 end=总页数 if(totalPage&lt;=10){ b =1; e = totalPage; //如果总页数 &gt; 10，让begin=当前页 - 5 end=当前页+4 }else if(totalPage&gt;10){ b = pno-5; e = pno+4; //头溢出：如果当前页=3，begin=3-5=-2 头溢出 如果begin&lt;1 让begin=1 end=10 if(b&lt;1){ b=1; e=10; //尾溢出 如果end &gt; 总页数，让end=总页数 begin=总页数-9 }else if(e&gt;totalPage){ b= totalPage-9; e = totalPage; } } //显示分页页码 for(var pageIndex= b;pageIndex&lt;e+1;pageIndex++){ tempStr += &quot;&lt;li class=&apos;pageno&apos; onclick=\&quot;goPage(&quot;+pageIndex+&quot;)\&quot;&gt;&quot;+ pageIndex +&quot;&lt;/li&gt;&quot;; } //下一页 if(currentPage&lt;totalPage){ tempStr += &quot;&lt;div class=&apos;one o-right&apos; onClick=\&quot;goPage(&quot;+(currentPage+1)+&quot;)\&quot;&gt;&lt;/div&gt;&quot;; }else{ tempStr += &quot;&lt;div class=&apos;one o-right&apos;&gt;&lt;/div&gt;&quot;; } //为了给点击事件添加选中状态 document.getElementById(&quot;page&quot;).innerHTML = tempStr; $(&quot;.pageno&quot;).each(function(i,v){ if($(v).text() ==pno){ $(v).addClass(&quot;activeLi&quot;); } }) } jsp页面中代码如下：&lt;ul id=&quot;page&quot;&gt;&lt;/ul&gt; 分页的逻辑如下 如果totalPage &lt;= 10 ，那说明总页数一共都没有10页。begin=1 end=totalPage 如果totalPage &gt; 10，说明总页数超过10页了。begin=pageCode-5 end=pageCode+4 头部溢出 当begin &lt; 1 begin=1 end=10 尾部溢出 当end&gt;totalPage的时候，end=totalPage begin=totalPage-9]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入sql语句的拼接]]></title>
    <url>%2F2018%2F01%2F21%2Fsql%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[需求 点击保存的时候需要将上面四条数据添加到数据库中，并将原数据库中的数据清空，添加新的数据 js代码如下： var sjArray = []; $(&quot;tr&quot;).each(function(i,v){//遍历tr var yarray = []; if(i &gt;= 1){ $(v).find(&quot;td&quot;).each(function(i1,v1){//遍历tr下面的td if(i1 &lt; $(v).find(&quot;td&quot;).length-1){ yarray.push($(v1).find(&quot;input&quot;).val()); } }) } sjArray.push(yarray) }) $.ajax({ type:&quot;POST&quot;, url:contextPath + &apos;/ChartElementInfo/sdlrAjbxxAysszSave&apos;, dataType:&quot;json&quot;, data:{num:num,newArr:JSON.stringify(sjArray)}, async: false, success:function(result){ if (result.code == 200) { alert(&quot;添加成功&quot;); window.location.href = contextPath + &apos;/ChartElementInfo/toshow&apos;; }else{ alert(&quot;添加失败&quot;); } } }); 后台接收到的sjarray的格式如下： 使用sql插入功能，使用insert的方法insert into tablename(id,name)values(x,x);格式 后台代码如下： /* * 手动录入数据的保存 */ @Transactional(propagation=Propagation.SUPPORTS) @Override public void getSave(String num,String newArr) throws Exception{ JSONArray jsonArray = JSONArray.parseArray(newArr); ChartElementInfo info = this.get(num); String dataTable = info.getDataTable(); //将数据库中内容清空 this.chartElementInfoDao.del(dataTable); //遍历jsonArray将数据保存到list中 List&lt;List&lt;Object&gt;&gt; data = new ArrayList&lt;List&lt;Object&gt;&gt;(); for (int i =1; i&lt;jsonArray.size();i++) { String obj = jsonArray.get(i).toString(); List&lt;Object&gt; row = new ArrayList&lt;Object&gt;(); JSONArray array = JSONArray.parseArray(obj); for (int j=0; j&lt;array.size();j++) { String str = array.get(j).toString(); row.add(str); } data.add(row); } //字段拼接 String flieds = &quot;id&quot;; List&lt;ChartElementData&gt; list = this.chartElementDataService.getChartElementDataByFkId(num); Database database = this.dataBaseService.get(info.getDatabaseId()); this.getConnection(database); Statement statement = null; //拿到需要添加数据的字段名称 for (ChartElementData chartElementData : list) { flieds = flieds+&quot;,&quot;+chartElementData.getFieldName(); String type = chartElementData.getDataType(); } //拼接需要添加的数据 for (List&lt;Object&gt; list2 : data) { //数据拼接 String datas = &quot;&apos;&quot;+UuidUtil.uuids()+&quot;&apos;&quot;; for (Object object : list2) { if(object instanceof java.lang.String){ datas = datas+&quot;,&apos;&quot;+object+&quot;&apos;&quot;; }else{ datas = datas+&quot;,&quot;+object; } } try { statement = connection.getConn().createStatement(); String sql = &quot;insert into &quot;+dataTable+&quot;(&quot;+flieds+&quot;) values(&quot;+datas+&quot;)&quot;; statement.executeUpdate(sql); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } } } //关闭连接 connection.closeConn(); }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js写的模糊查询]]></title>
    <url>%2F2018%2F01%2F21%2Fjs%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[需求 页面上需要进行模糊查询匹配，使用js完成，效果如下： 通过主题和名称组成的多条件查询首先，要把数据组装成下面的格式： var treejson=[{ id:&apos;theme0&apos;, nodename:&apos;经济主题&apos;,//节点名称 children:[{id:&apos;1&apos;,nodename:&apos;规模增长及增速&apos;},{id:&apos;2&apos;,nodename:&apos;产业构成&apos;},{id:&apos;3&apos;,nodename:&apos;社会消费品构成&apos;}] },{ id:&apos;theme1&apos;, nodename:&apos;人口主题&apos;,//节点名称 children:[{id:&apos;4&apos;,nodename:&apos;规模增长及增速&apos;},{id:&apos;5&apos;,nodename:&apos;贫困特征&apos;}] }] 前端js代码的格式如上面的格式，由于在前端不好组装数据，所以在后台进行数据的组装，后台代码 如下： List&lt;Map&lt;String,Object&gt;&gt; list = themeService.getThemes(); List&lt;Map&lt;String,Object&gt;&gt; listJson = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); for (Map&lt;String, Object&gt; map2 : list) { String themeId = map2.get(&quot;id&quot;).toString(); //获取图元数据 List&lt;Map&lt;String, Object&gt;&gt; info = service.getInfo(themeId); //查询数据的组装 Map&lt;String,Object&gt; jmap = new HashMap&lt;String, Object&gt;(); Object obj = map2.get(&quot;id&quot;); jmap.put(&quot;id&quot;, obj); Object obj1 = map2.get(&quot;name&quot;); jmap.put(&quot;nodename&quot;, obj1); jmap.put(&quot;children&quot;, info); listJson.add(jmap); } //查询数据 setAttribute(&quot;charInfoListJson&quot;, JsonUtil.toJson(listJson)); 这样就可以把数据组装成上面所对应的格式了，下面就是所对应的前端代码了，jsp代码如下 &lt;div class=&quot;message&quot; id=&quot;animate&quot;&gt; &lt;div class=&quot;line&quot;&gt; &lt;div class=&quot;lineC&quot; id=&quot;1&quot;&gt; &lt;span class=&quot;text&quot;&gt;人口主题&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;ul style=&quot;display: block;&quot;&gt; &lt;li class=&quot;active&quot; id=&quot;1&quot; onclick=&quot;gb1(this);&quot;&gt;人口流入&lt;/li&gt; &lt;li id=&quot;2&quot; onclick=&quot;gb1(this);&quot;&gt;就业人口行业分布&lt;/li&gt; &lt;li id=&quot;3&quot; onclick=&quot;gb1(this);&quot;&gt;近年人口增长率&lt;/li&gt; &lt;li id=&quot;4&quot; onclick=&quot;gb1(this);&quot;&gt;人口流出&lt;/li&gt; &lt;li id=&quot;5&quot; onclick=&quot;gb1(this);&quot;&gt;近年失业率统计&lt;/li&gt; &lt;li id=&quot;6&quot; onclick=&quot;gb1(this);&quot;&gt;文化程度分析&lt;/li&gt; &lt;li id=&quot;7&quot; onclick=&quot;gb1(this);&quot;&gt;近年婚姻状况分析&lt;/li&gt; &lt;li id=&quot;8&quot; onclick=&quot;gb1(this);&quot;&gt;各年龄段人口数&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;rightInfo fr w84 economic-left&quot;&gt; &lt;div class=&quot;tuyuan w100&quot; id=&quot;tuyuan&quot;&gt; &lt;div class=&quot;fonud&quot;&gt; &lt;span&gt;主题：&lt;/span&gt; &lt;select name=&quot;&quot; id=&quot;father&quot;&gt; &lt;option value=&quot;main&quot;&gt;全部&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;人口主题&lt;/option&gt; &lt;option value=&quot;8a90fb266095aca7016095d66fff0006&quot;&gt;法人主题&lt;/option&gt; &lt;option value=&quot;8a90fb266095aca7016095d688f80007&quot;&gt;农业主题&lt;/option&gt; &lt;option value=&quot;8a90fb266095aca7016095d6ac6f0008&quot;&gt;经济主题&lt;/option&gt; &lt;option value=&quot;8a90fb266095aca7016095d6c2770009&quot;&gt;旅游主题&lt;/option&gt; &lt;/select&gt; &lt;span&gt;名称：&lt;/span&gt; &lt;input id=&quot;son&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;&gt; &lt;a href=&quot;javascript:search()&quot;&gt;查询&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;chart&quot; id=&quot;chart&quot; style=&quot;overflow: auto;&quot;&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;ztBox&quot; id=&quot;1&quot;&gt; &lt;div class=&quot;zt-title&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;人口主题&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;ztinfo clearfix&quot;&gt; &lt;div class=&quot;w33 fl checked&quot; data-num=&quot;1&quot; data-type=&quot;10&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop11&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;人口流入&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; data-num=&quot;2&quot; data-type=&quot;1&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop12&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;就业人口行业分布&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; style=&quot;margin-right: 0px;&quot; data-num=&quot;3&quot; data-type=&quot;2&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop13&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;近年人口增长率&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; data-num=&quot;4&quot; data-type=&quot;11&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop14&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;人口流出&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; data-num=&quot;5&quot; data-type=&quot;8&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop15&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;近年失业率统计&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; style=&quot;margin-right: 0px;&quot; data-num=&quot;6&quot; data-type=&quot;9&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop16&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;文化程度分析&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; data-num=&quot;7&quot; data-type=&quot;8&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop17&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;近年婚姻状况分析&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w33 fl&quot; data-num=&quot;8&quot; data-type=&quot;5&quot;&gt; &lt;div class=&quot;pixel&quot; onclick=&quot;preview(this);&quot;&gt; &lt;div id=&quot;drop18&quot; class=&quot;w100&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pixel-txt&quot; onclick=&quot;revise(this);&quot;&gt;各年龄段人口数&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 对应的js代码如下： function search(){ var theme=$(&apos;#father&apos;).find(&quot;option:selected&quot;).text(); var value=$(&apos;#son&apos;).val(); //删除列表及图元的选中状态 $(&apos;#box .w33&apos;).removeClass(&quot;checked&quot;); $(&apos;#animate li&apos;).removeClass(&quot;active&quot;); //隐藏主题及下属的chart if(theme==&quot;全部&quot;){//全部主题时的查询方法 if(value.length==0){ $(&quot;#box .ztBox&quot;).css(&quot;display&quot;,&quot;block&quot;); $(&quot;#box .w33&quot;).css(&quot;display&quot;,&quot;block&quot;); //根据主题的索引index去匹配左侧树，及右侧树的层级结构： $(&quot;#box .ztBox&quot;).each(function(i,v){ if($(v).index()==0){ $(v).find(&quot;.w33&quot;).each(function(i1,v1){ if($(v1).index()==0){ $(v1).css(&quot;display&quot;,&quot;block&quot;); $(v1).addClass(&quot;checked&quot;); } else{ $(v1).css(&quot;display&quot;,&quot;block&quot;); } }) } }); $(&quot;#animate .line&quot;).each(function(i,v){ if($(v).index()==0){ $(v).find(&quot;ul li&quot;).each(function(i1,v1){ if($(v1).index()==0){ $(v1).addClass(&quot;active&quot;); } }); } }); } else{ $(&quot;#box .ztBox&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#box .w33&quot;).css(&quot;display&quot;,&quot;none&quot;); for(var t=0;t&lt;treejson.length;t++){ var children=treejson[t].children; var id=treejson[t].id; var index; for(var i=0;i&lt;children.length;i++ ){ //模糊匹配 if(children[i].nodename.indexOf(value)&gt;=0){ var theme=treejson[t].nodename; var child_id=children[i].id; $(&apos;#box .ztBox&apos;).each(function(i,v){ if($(v).find(&apos;span&apos;).text()==theme){ $(this).css(&quot;display&quot;,&quot;block&quot;); } }); $(&quot;#box .w33&quot;).each(function(i,v){ if ($(v).attr(&quot;data-num&quot;) == child_id) { $(this).css(&quot;display&quot;,&quot;block&quot;); $(this).addClass(&quot;checked&quot;); } }) $(&quot;#animate li&quot;).each(function(i1,v1){ if($(v1).attr(&quot;id&quot;) == child_id){ $(this).addClass(&quot;active&quot;); } }) } } } } } else{//有特定主题的查询方法 $(&quot;#box .ztBox&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#box .w33&quot;).css(&quot;display&quot;,&quot;none&quot;); for(var j=0;j&lt;treejson.length;j++){ if(treejson[j].nodename==theme){ var children=treejson[j].children; var id=treejson[j].id; var index; $(&quot;#box .ztBox&quot;).each(function(i,v){ if ($(v).attr(&quot;id&quot;) == id) { $(this).css(&quot;display&quot;,&quot;block&quot;); index=$(this).index(); } }) if(value.length&gt;0){ var flag=0; for(var i=0;i&lt;children.length;i++ ){ //模糊匹配 if(children[i].nodename.indexOf(value)&gt;=0){ flag++; var child_id=children[i].id; $(&quot;#box .w33&quot;).each(function(i,v){ if ($(v).attr(&quot;data-num&quot;) == child_id) { $(this).css(&quot;display&quot;,&quot;block&quot;); $(this).addClass(&quot;checked&quot;); } }) $(&quot;#animate li&quot;).each(function(i1,v1){ if($(v1).attr(&quot;id&quot;) == child_id){ $(this).addClass(&quot;active&quot;); } }) } } } else if(value.length==0){ //根据主题的索引index去匹配左侧树，及右侧树的层级结构： $(&quot;#box .ztBox&quot;).each(function(i,v){ if($(v).index()==index){ $(v).find(&quot;.w33&quot;).each(function(i1,v1){ if($(v1).index()==0){ $(v1).css(&quot;display&quot;,&quot;block&quot;); $(v1).addClass(&quot;checked&quot;); } else{ $(v1).css(&quot;display&quot;,&quot;block&quot;); } }) } }); $(&quot;#animate .line&quot;).each(function(i,v){ if($(v).index()==index){ $(v).find(&quot;ul li&quot;).each(function(i1,v1){ if($(v1).index()==0){ $(v1).addClass(&quot;active&quot;); } }); } }); } } } //主题循环查询结束 } //else结束 }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取表格中每一列的值]]></title>
    <url>%2F2018%2F01%2F21%2F%E8%8E%B7%E5%8F%96%E8%A1%A8%E6%A0%BC%E4%B8%AD%E6%AF%8F%E5%88%97%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[需求 工作中需要将获取到表格中的每一列的值，每一列的值放到数组中，然后将其发替换echart的option中的值 需要将年份的值放到一个数组中，在将增长率的值放到一个数组中，然后将其的值放到echarts中，如图： 前台获取表格中每一列值的代码如下：var arr2=[]; //遍历tr下面的td的值 for(var k=0;k&lt;$(&quot;tr&quot;).eq(1).find(&quot;td&quot;).length-1;k++){ var arr1 = []; $(&quot;tr&quot;).each(function(i3,v3){ if(i3 &gt;= 1){ var v=$(this).find(&quot;td&quot;).eq(k) //每一列的值 arr1.push(v.find(&quot;input&quot;).val()); } }) arr2.push(arr1); 获取表头的值，拿表头的值去与option中的图例的值进行比较，相等的话就将其替换//为了拿表头的值 var laArr = [] $(&quot;tr&quot;).each(function(ii,vv){ if(ii == 0){ $(vv).find(&quot;th&quot;).each(function(ii1,vv1){ if(ii1 &lt; $(vv).find(&quot;th&quot;).length-1){ laArr.push($(vv1).find(&quot;label&quot;).text()); } }) } }) //使用表头的值与option中的图例的值进行比较，如果相同的话就将其替换 option.xAxis[0].data = arr2[0]; var series = option.series; for(var i = 0;i&lt;series.length;i++){ var seriesName = series[i].name; for(var j= 1;j&lt;laArr.length;j++){// var name = laArr[j]; if(name == seriesName ){ option.series[i].data = arr2[j]; } } }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js、table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格实现按年龄排序]]></title>
    <url>%2F2018%2F01%2F21%2F%E8%A1%A8%E6%A0%BC%E5%AE%9E%E7%8E%B0%E6%8C%89%E7%85%A7%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[需求 实现点击刷新的时候按照年份进行排序，使其按照年份进行正序排序，最终效果如下： jsp代码如下&lt;table id=&quot;edit&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;label class=&quot;cc0&quot; for=&quot;nf&quot; data-type=&quot;INTEGER&quot;&gt;年份&lt;/label&gt;&lt;input type=&quot;hidden&quot;&gt;&lt;/th&gt; &lt;th&gt;&lt;label class=&quot;cc1&quot; for=&quot;zcl&quot; data-type=&quot;DECIMAL&quot;&gt;增长率&lt;/label&gt;&lt;input type=&quot;hidden&quot;&gt;&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;&quot; autofocus=&quot;&quot; onkeyup=&quot;shuzi(this);&quot;&gt; &lt;div class=&quot;tips&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;&quot; onkeyup=&quot;xiaoshu(this);&quot;&gt; &lt;div class=&quot;tips&quot; style=&quot;display: none;&quot;&gt;请输入数字，并且保留两位小数&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;2011&quot; onkeyup=&quot;shuzi(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;52.08&quot; onkeyup=&quot;xiaoshu(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;2012&quot; onkeyup=&quot;shuzi(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;51.12&quot; onkeyup=&quot;xiaoshu(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;2013&quot; onkeyup=&quot;shuzi(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;50.01&quot; onkeyup=&quot;xiaoshu(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;2014&quot; onkeyup=&quot;shuzi(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;&quot; value=&quot;45.88&quot; onkeyup=&quot;xiaoshu(this);&quot;&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; js代码如下function sortTable(){ /* * 思路： * 1，排序就需要数组。获取需要参与排序的行对象数组。 * 2，对行数组中的每一个行的年龄单元格的数据进行比较，并完成行对象在数组中的位置置换。 * 3，将排好序的数组重新添加回表格。 */ var oTabNode = document.getElementById(&quot;edit&quot;); var collTrNodes = oTabNode.rows; //定义一个临时容器，存储需要排序行对象。 var trArr = []; //遍历原行集合，并将需要排序的行对象存储到临时容器中。 for(var x=1; x&lt;collTrNodes.length; x++){ trArr[x-1] = collTrNodes[x]; } //对临时容器排个序。 mySort(trArr); for (var x = 0; x &lt; trArr.length; x++) { trArr[x].parentNode.appendChild(trArr[x]); } } function mySort(arr){ var temp; for(var i=0; i&lt;arr.length; i++) { for(var j=i+1; j&lt;arr.length; j++) { var td = arr[i].cells[0]; var td1 = arr[j].cells[0]; if(parseInt($(td).find(&apos;input&apos;).val())&gt;parseInt($(td1).find(&apos;input&apos;).val())) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js、table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态创建表格]]></title>
    <url>%2F2018%2F01%2F21%2Fjs%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[需求 项目中为了要实现手动在表格里面添加数据，每点击一次增加添加一行，然后在表格中添加数据，最后将其保存到数据库中效果如下图： 添加一行，录入数据 jsp代码如下：&lt;table id=&quot;edit&quot;&gt;&lt;/table&gt; 数据表格的拼接和数据回显的就是代码如下：//点击图元信息的时候拼接表格 function sdSr(num,data_type,dataname){ var html = &apos;&apos;; var trHtml = &apos;&apos;; $.post(contextPath+&quot;/ChartElementInfo/dataList&quot;,{&apos;id&apos;:num,&apos;name&apos;:dataname},function(result){ html+=&apos;&lt;thead&gt;&lt;tr&gt;&apos; var datalist = result.dalist; var mlist = result.mlist; //循环添加表头，将其拼接在一起 for(var i=0;i&lt;datalist.length;i++){ html += &apos;&lt;th&gt;&lt;label class=&quot;cc&apos;+i+&apos;&quot; for=&quot;&apos;+datalist[i].FIELD_NAME+&apos;&quot; data-type=&quot;&apos;+datalist[i].DATA_TYPE+&apos;&quot;&gt;&apos;+datalist[i].FIELD_COMMENT+&apos;&lt;/label&gt;&lt;input type=&quot;hidden&quot;/&gt;&lt;/th&gt;&apos;; } html += &apos;&lt;th&gt;操作&lt;/th&gt;&apos;; html +=&apos;&lt;/tr&gt;&lt;/thead&gt;&apos; $(&quot;#edit&quot;).html(html);//将其添加到表格中 //循环遍历数据中的数据，将其添加到表格中对应的表头下面 for(var j =0;j&lt;mlist.length;j++){ var trHtml = &apos;&lt;tr&gt;&apos;; //循环遍历表头，以便于数据添加到表头下面 for(var i=0;i&lt;datalist.length;i++){ $(&quot;th&quot;).each(function(i,v){ if(i == $(&quot;th&quot;).length - 1){//判断th的长度，如果是最后一个让其显示删除图标 trHtml += &apos;&lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt;&apos; }else{ if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;STRING&quot;){//判断字段的类型是否是String类型的 trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; type=&quot;text&quot; value = &quot;&apos;+mlist[j][datalist[i].FIELD_NAME]+&apos;&quot; onkeyup=&quot;Str(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; }else if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;INTEGER&quot;){ trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; value = &quot;&apos;+mlist[j][datalist[i].FIELD_NAME]+&apos;&quot; onkeyup=&quot;shuzi(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; }else if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;DECIMAL&quot;){ trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; value = &quot;&apos;+mlist[j][datalist[i].FIELD_NAME]+&apos;&quot; onkeyup=&quot;xiaoshu(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; } /* trHtml += &apos;&lt;td&gt;&lt;input id=&quot;&quot; name=&quot;&quot; type=&quot;text&quot; value=&quot;&apos;+i+&apos;&quot;/&gt;&lt;/td&gt;&apos; */ } }) trHtml +=&apos;&lt;/tr&gt;&apos;; $(&quot;#edit&quot;).append(trHtml); break; } } }); } 点击增加的时候追加一行，并且验证文本框的值//点击增加时追加一行 function creat(){ var aa = &apos;&apos;; var trHtml = &apos;&lt;tr&gt;&apos;; //循环表头的th，在其下面添加对用的tr $(&quot;th&quot;).each(function(i,v){ if(i == $(&quot;th&quot;).length - 1){ trHtml += &apos;&lt;td&gt;&lt;em onclick=&quot;del(this)&quot;&gt;&lt;/em&gt;&lt;/td&gt;&apos; }else{ if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;STRING&quot;){ //autofocus添加焦点，添加一行后会自动定位到该行 trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; type=&quot;text&quot; autofocus onkeyup=&quot;Str(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; }else if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;INTEGER&quot;){ trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; autofocus onkeyup=&quot;shuzi(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; }else if($(v).find(&quot;label&quot;).attr(&quot;data-type&quot;) == &quot;DECIMAL&quot;){ trHtml += &apos;&lt;td&gt;&lt;input name=&quot;&quot; onkeyup=&quot;xiaoshu(this);&quot;/&gt;&lt;div class=&quot;tips&quot;&gt;&lt;/div&gt;&lt;/td&gt;&apos; } /* trHtml += &apos;&lt;td&gt;&lt;input id=&quot;&quot; name=&quot;&quot; type=&quot;text&quot; value=&quot;&apos;+i+&apos;&quot;/&gt;&lt;/td&gt;&apos; */ } }) trHtml +=&apos;&lt;/tr&gt;&apos;; $(&quot;#edit&quot;).append(trHtml); } function Str(ele){ if(&apos;&apos; == $(ele).val() || null == $(ele).val()){ var txt = $(ele).siblings(&quot;.tips&quot;).text(&quot;不能为空,请输入&quot;).text(); show(ele,txt); setTimeout(function(){hide(ele);},5000);//使其显示5秒后自动消失 return; } else{ $(ele).siblings(&quot;.tips&quot;).hide(); } } //校验数字 function shuzi(ele){ if((/[^\d]/.test($(ele).val()))){//替换非数字字符 var txt = $(ele).siblings(&quot;.tips&quot;).text(&quot;请输入正确的数字&quot;).text(); var temp_amount=$(ele).val().replace(/[^\d]/g,&apos;&apos;); $(ele).val(temp_amount); show(ele,txt); setTimeout(function(){hide(ele);},5000); return; } else if(&apos;&apos; == $(ele).val() || null == $(ele).val()){ var txt = $(ele).siblings(&quot;.tips&quot;).text(&quot;不能为空,请输入正确的数字&quot;).text(); show(ele,txt); setTimeout(function(){hide(ele);},5000); return; } else{ $(ele).siblings(&quot;.tips&quot;).hide(); } } //校验小数 function xiaoshu(ele){ var reg = /^\d+(\.\d{1,2})?$/; if(!reg.test($(ele).val())){//替换非数字字符 var txt = $(ele).siblings(&quot;.tips&quot;).text(&quot;请输入数字，并且保留两位小数&quot;).text(); var temp_amount=$(ele).val().replace(/[^\d\.]/g,&apos;&apos;); $(ele).val(temp_amount); show(ele,txt); setTimeout(function(){hide(ele);},5000); return; }else if(&apos;&apos; == $(ele).val() || null == $(ele).val()){ var txt = $(ele).siblings(&quot;.tips&quot;).text(&quot;不能为空,请输入正确的数字&quot;).text(); show(ele,txt); setTimeout(function(){hide(ele);},5000); return; } else{ $(ele).siblings(&quot;.tips&quot;).hide(); } } //点击删除时删除行 function del(ele){ $(ele).closest(&quot;tr&quot;).remove(); } /* 控制提示框内的提示词的显示效果 */ var i = 0; function show(ediv,txt) { $(ediv).siblings(&quot;.tips&quot;).text(txt); $(ediv).siblings(&quot;.tips&quot;).show(); /* $(ediv).siblings(&quot;.tips&quot;).animate({opacity:&quot;1&quot;},1000); */ } function hide(e1) { $(e1).siblings(&quot;.tips&quot;).hide(); }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js、table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索框使用插件出搜索提示]]></title>
    <url>%2F2018%2F01%2F21%2F%E5%B0%B1%E6%98%AF%E3%80%81%2F</url>
    <content type="text"><![CDATA[首先需要在jsp页面上导入两个js 查询条件jsp处代码如下： js对应的方法如下： 那个array，是后台查出来的数据，添加到数组中]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索框使用插件出搜索提示]]></title>
    <url>%2F2018%2F01%2F21%2Fjs%E6%8F%90%E7%A4%BA%E6%A1%86%2F</url>
    <content type="text"><![CDATA[首先需要在jsp页面上导入两个js 查询条件jsp处代码如下： js对应的方法如下： 那个array，是后台查出来的数据，添加到数组中]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中map的使用]]></title>
    <url>%2F2018%2F01%2F21%2Fjs%E4%B8%ADmap%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[js中map使用HashMap是一种非常使用的、应用广泛的数据类型。代码如下： function HashMap(){ this.map = {}; } HashMap.prototype = { put : function(key , value){ this.map[key] = value; }, get : function(key){ if(this.map.hasOwnProperty(key)){ return this.map[key]; } return null; }, remove : function(key){ if(this.map.hasOwnProperty(key)){ return delete this.map[key]; } return false; }, removeAll : function(){ this.map = {}; }, keySet : function(){ var _keys = []; for(var i in this.map){ _keys.push(i); } return _keys; } }; HashMap.prototype.constructor = HashMap; hashmap的使用 var hashMap = new HashMap();//向hashmap中存放值hashMap.put(a,b);//从map中取值hashMap.get(a);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js、map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java导入excel表格]]></title>
    <url>%2F2018%2F01%2F21%2Fjava%E4%B8%ADexcel%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[excel表格内容 java代码如下：public void aaa(){ List&lt;SchoolZcxx&gt; list = new ArrayList&lt;SchoolZcxx&gt;(); File file = new File(&quot;d:\\school.xlsx&quot;); InputStream in = null; try { in = new FileInputStream(file); } catch (FileNotFoundException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } ExcelReader&lt;SchoolZcxx&gt; excelReader = new ExcelReader&lt;SchoolZcxx&gt;(0, 3, 0, null, SchoolZcxx.class); try { list = excelReader.read(in); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } for (SchoolZcxx schoolZcxx : list) { //封装对象 SchoolInfo jbxxPojo = new SchoolInfo(); String str = Dzppzb.geocode(schoolZcxx.getDz()); if (!StringUtil.isEmpty(str)) { String[] xxx =str.split(&quot; &quot;); if(xxx != null &amp;&amp; xxx.length==2){ String x = xxx[0]; String y = xxx[1]; if (!StringUtil.isEmpty(x) &amp;&amp; !StringUtil.isEmpty(y)) { x = x.substring(0, 10); y = y.substring(0, 9); jbxxPojo.setX(new BigDecimal(x)); jbxxPojo.setY(new BigDecimal(y)); } } } jbxxPojo.setXxmc(schoolZcxx.getMc()); jbxxPojo.setXxbh(schoolZcxx.dm); if (schoolZcxx.getMc().contains(&quot;武山县&quot;) || schoolZcxx.getDz().contains(&quot;武山县&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;武山县&quot;); jbxxPojo.setSzdxzqhbm(&quot;620524&quot;); } if (schoolZcxx.getMc().contains(&quot;甘谷县&quot;) || schoolZcxx.getDz().contains(&quot;甘谷县&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;甘谷县&quot;); jbxxPojo.setSzdxzqhbm(&quot;620523&quot;); } if (schoolZcxx.getMc().contains(&quot;秦州区&quot;) || schoolZcxx.getDz().contains(&quot;秦州区&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;秦州区&quot;); jbxxPojo.setSzdxzqhbm(&quot;620502&quot;); } if (schoolZcxx.getMc().contains(&quot;麦积区&quot;) || schoolZcxx.getDz().contains(&quot;麦积区&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;麦积区&quot;); jbxxPojo.setSzdxzqhbm(&quot;620503&quot;); } if (schoolZcxx.getMc().contains(&quot;秦安县&quot;) || schoolZcxx.getDz().contains(&quot;秦安县&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;秦安县&quot;); jbxxPojo.setSzdxzqhbm(&quot;620522&quot;); } if (schoolZcxx.getMc().contains(&quot;清水县&quot;) || schoolZcxx.getDz().contains(&quot;清水县&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;清水县&quot;); jbxxPojo.setSzdxzqhbm(&quot;620521&quot;); } if (schoolZcxx.getMc().contains(&quot;张家川&quot;) || schoolZcxx.getDz().contains(&quot;张家川&quot;)) { jbxxPojo.setSzdxzqhmc(&quot;张家川&quot;); jbxxPojo.setSzdxzqhbm(&quot;620525&quot;); } jbxxPojo.setXxlx(&quot;6&quot;); jbxxPojo.setDizhi(schoolZcxx.getDz()); jbxxPojo.setXxb(schoolZcxx.tb); this.schoolInfoService.add(jbxxPojo); System.out.println(&quot;$$$$$$$$$$$$$$$$$$$$$$$$&quot;); } System.out.println(&quot;GAME OVER!!!&quot;); } 用到的工具类如下：package com.cloud.icenter.yyzx.common.util.excel.reader; import java.io.InputStream; import java.lang.reflect.Field; import java.math.BigDecimal; import java.math.BigInteger; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.Map; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import com.cloud.icenter.yyzx.common.util.excel.AnnotationFieldUtil; import com.cloud.icenter.yyzx.common.util.excel.ExcelFieldInfo; import com.cloud.icenter.yyzx.common.util.excel.WorkBookUtil; import com.cloud.icenter.yyzx.common.util.excel.annotation.ExcelObject; /** * * Excel读取器 */ public class ExcelReader&lt;T&gt; { private Integer startColumn; private Integer endColumn; private Integer startRow; private Integer endRow; private Class&lt;T&gt; clazz; private Map&lt;String, ExcelFieldInfo&gt; fieldMaps; public void setStartColumn(Integer startColumn) { this.startColumn = startColumn; } public void setEndColumn(Integer endColumn) { this.endColumn = endColumn; } public void setStartRow(Integer startRow) { this.startRow = startRow; } public void setEndRow(Integer endRow) { this.endRow = endRow; } /** * Excel数据读取器 * * @param startColumn * 起始列（必填，从0开始） * @param endColumn * 终止列（必填） * @param startRow * 起始行 （可以为NULL，从0开始，默认从第0行开始） * @param endRow * 终止行 （可以为NULL） * @param clazz */ public ExcelReader(Integer startColumn, Integer endColumn, Integer startRow, Integer endRow, Class&lt;T&gt; clazz) { this.startColumn = startColumn; this.endColumn = endColumn; this.startRow = startRow; this.endRow = endRow; this.clazz = clazz; this.fieldMaps = AnnotationFieldUtil.fieldMaps(this.clazz); } /** * Excel数据读取器 * * @param startColumn * 起始列（必填，从0开始） * @param endColumn * 终止列（必填） * @param startRow * 起始行 （可以为NULL，从0开始，默认从第0行开始） * @param clazz */ public ExcelReader(Integer startColumn, Integer endColumn, Integer startRow, Class&lt;T&gt; clazz) { this(startColumn, endColumn, startRow, null, clazz); } /** * Excel数据读取器 * * @param startColumn * 起始列（必填，从0开始） * @param endColumn * 终止列（必填） * @param clazz */ public ExcelReader(Integer startColumn, Integer endColumn, Class&lt;T&gt; clazz) { this(startColumn, endColumn, null, null, clazz); } /** * 读取Excel数据 * * @Title read * @Description TODO * @param in * Excel数据流 * @return 读取结果 * @throws Exception * @date 2015年11月16日-上午9:33:35 * @update * */ public List&lt;T&gt; read(InputStream in) throws Exception { Workbook hssfWorkbook = WorkBookUtil.createWorkBook(in); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); if (null == startColumn) { throw new NullPointerException(&quot;Please set startColumn！&quot;); } if (null == endColumn) { throw new NullPointerException(&quot;Please set endColumn！&quot;); } for (int numSheet = 0; numSheet &lt; hssfWorkbook.getNumberOfSheets(); numSheet++) { Sheet sheet = hssfWorkbook.getSheetAt(numSheet); if (sheet == null) { continue; } int lastRowNum = null != endRow ? endRow : sheet.getLastRowNum(); int rowNum = null != startRow ? startRow : 0; if (clazz == List.class) { readToList(sheet, list, lastRowNum, rowNum); } else { readToBean(sheet, list, lastRowNum, rowNum); } } return list; } /** * 读取数据为List&amp;lt;List&amp;lt;Object&amp;gt;&amp;gt;类型 * * @Title readToList * @Description TODO * @param sheet * @param list * @param lastRowNum * @param rowNum * @throws Exception * @date 2015年11月16日-上午9:34:12 * @update * */ @SuppressWarnings(&quot;unchecked&quot;) private void readToList(Sheet sheet, List&lt;T&gt; list, int lastRowNum, int rowNum) throws Exception { for (; rowNum &lt;= lastRowNum; rowNum++) { Row hssfRow = sheet.getRow(rowNum); if (null == hssfRow) { break; } List&lt;Object&gt; inList = new ArrayList&lt;Object&gt;(); for (int column = startColumn; column &lt;= endColumn; column++) { Cell cell = hssfRow.getCell(column); String str = WorkBookUtil.getValue(cell); inList.add(str); } list.add((T) inList); } } /** * 读取数据为List&amp;lt;Object&amp;gt;类型,其中Object为通过泛型设置的类型 * * @Title readToBean * @Description TODO * @param sheet * @param list * @param lastRowNum * @param rowNum * @throws Exception * @date 2015年11月16日-上午9:35:44 * @update * */ private void readToBean(Sheet sheet, List&lt;T&gt; list, int lastRowNum, int rowNum) throws Exception { ExcelObject excelObject = clazz.getAnnotation(ExcelObject.class); if (null == excelObject || !excelObject.value()) { return; } for (; rowNum &lt;= lastRowNum; rowNum++) { Row hssfRow = sheet.getRow(rowNum); if (null == hssfRow) { break; } if (WorkBookUtil.rowIsNull(hssfRow, startColumn, endColumn)) { return; } T obj = (T) Class.forName(clazz.getName()).newInstance(); int excelColumn = 1; for (int column = startColumn; column &lt;= endColumn; column++) { Cell cell = hssfRow.getCell(column); ExcelFieldInfo excelField = fieldMaps.get(excelColumn++ + &quot;&quot;); String strValue = WorkBookUtil.getValue(cell); if (null == strValue || strValue.trim().length()==0) { continue; } Field field = excelField.getField(); Class&lt;?&gt; fieldClazz = field.getType(); if (fieldClazz == String.class) { field.set(obj, strValue); } else if (fieldClazz == Integer.class || fieldClazz == int.class) { field.set(obj, CellDataReader.readInt(strValue)); } else if (fieldClazz == short.class || fieldClazz == Short.class) { field.set(obj, CellDataReader.readShort(strValue)); } else if (fieldClazz == long.class || fieldClazz == Long.class) { field.set(obj, CellDataReader.readLong(strValue)); } else if (fieldClazz == float.class || fieldClazz == Float.class) { int decimal = Integer.parseInt(excelField.getExcelField() .decimal()); field.set(obj, CellDataReader.readFloat(strValue, decimal)); } else if (fieldClazz == double.class || fieldClazz == Double.class) { int decimal = Integer.parseInt(excelField.getExcelField() .decimal()); field.set(obj, CellDataReader.readDouble(strValue, decimal)); } else if (fieldClazz == BigInteger.class) { field.set(obj, CellDataReader.readBigInteger(strValue)); } else if (fieldClazz == BigDecimal.class) { int decimal = Integer.parseInt(excelField.getExcelField() .decimal()); field.set(obj, CellDataReader.readBigDecimal(strValue, decimal)); } else if (fieldClazz == Date.class) { String dateFormat = excelField.getExcelField().dateFormat(); field.set(obj, CellDataReader.readDate(strValue, dateFormat)); } } list.add(obj); } } } 对应的pojopackage com.cloud.icenter.yyzx.fzjc.rk.pojo; import com.cloud.icenter.yyzx.common.util.excel.annotation.ExcelField; public class SchoolZcxx { @ExcelField(index = &quot;1&quot;) private String dm; @ExcelField(index = &quot;1&quot;) private String mc; @ExcelField(index = &quot;1&quot;) private String jbxx; @ExcelField(index = &quot;1&quot;) private String address; } 自定义注解如下package com.cloud.icenter.yyzx.common.util.excel.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ExcelField { /** * Excel列位置 * @Title index * @Description TODO * @return * @date 2015年11月11日-下午6:46:03 * @update * */ String index(); /** * 小数位数 * @Title decimal * @Description TODO * @return * @date 2015年11月11日-下午6:45:45 * @update * */ String decimal() default &quot;0&quot;; /** * 日期格式 * @Title dateFormat * @Description TODO * @return * @date 2015年11月16日-上午9:24:25 * @update * */ String dateFormat() default &quot;yyyy-MM-dd&quot;; }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决maven编译出现找不到符号问题]]></title>
    <url>%2F2018%2F01%2F21%2Fmaven%E7%BC%96%E8%AF%91%E8%A7%A3%E5%86%B3%E7%AC%A6%E5%8F%B7%E6%89%BE%E4%B8%8D%E5%88%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述搞了半天，Tomcat可以正常启动，就是Maven编译的时候一直出现“找不到符号”，网上到处找方法，说什么执行一下maven clear之类的，根本没用。于是自己想了想，看到出错的行，是jdk内的代码，并不是额外的jar文件。 所以初步判断问题出现在jdk上，经过一番查询，发现这个坑人的maven用的是jre，而我配置的项目jdk是JDK，并不是jre。 解决方案所以果断改成jre，再编译，成功！改完不要忘记了update一下项目。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F01%2F21%2Fjava%E9%80%92%E5%BD%92%E4%B8%8E%E5%8F%8D%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[title: java递归和反向递归tags: javacategories: java archives: /archives递归查询树tree结构有两种做法第一种，递归查询数据库结构，第二种，一次性将数据库表中的所有数据查出来，然后再递归查出来的list集合，第一种做法适合数据量较少的tree结构，因为要一直查询数据库数据量大时速度回相对较慢，所以数据量大时建议使用第二种方法，如图1所示是一个常见的树tree结构。图如下： 反向递归（逆向递归）查询树tree结构根据关键字过滤数据大家有么有遇到过这个问题：我想要根据关键字过滤查询出相关数据和它的上级结构，得到图1所示结果，可往往不知道怎么做，查不出上级结构总是得到图3类似的结构，要解决这个比较常见的问题就要用到反向递归的算法，网上我那个网搜不到类似的解决方案，本人一时兴趣来了，做了一套递归和反递归的解决方案，简单易懂，大家可以相互交流一下，图如下： 示例代码 1. /** 2. * 说明方法描述：将list转为树tree结构 3. * 4. * @param allRrecords 5. * @return 6. * @time 2016年5月10日 下午6:00:35 7. * @author yangdong 8. */ 9.public List&lt;Record&gt; useListRecordToTree(List&lt;Record&gt; allRrecords) { 10. 11.List&lt;Record&gt; listParentRecord = new ArrayList&lt;Record&gt;(); 12.List&lt;Record&gt; listNotParentRecord = new ArrayList&lt;Record&gt;(); 13.// 第一步：遍历allRrecords保存所有数据的uuid用于判断是不是根节点 14.Map&lt;String, String&gt; mapAllUuid = new HashMap&lt;String, String&gt;(); 15.Map&lt;String, Record&gt; allRecordMap = new HashMap&lt;String, Record&gt;(); 16.for (Record record : allRrecords) { 17.mapAllUuid.put(record.getStr(&quot;uuid&quot;), record.getStr(&quot;uuid&quot;)); 18.allRecordMap.put(record.getStr(&quot;uuid&quot;), record); 19.} 20.// 第二步：遍历allRrecords找出所有的根节点和非根节点 21.if (allRrecords != null &amp;&amp; allRrecords.size() &gt; 0) { 22.for (Record record : allRrecords) { 23.if (StringUtil.isBlank(record.getStr(&quot;parent_uuid&quot;)) 24.|| !mapAllUuid.containsKey(record.getStr(&quot;parent_uuid&quot;))) { 25.listParentRecord.add(record); 26.} else { 27.listNotParentRecord.add(record); 28.} 29.} 30.} 31. 32.// 第三步： 递归获取所有子节点 33.if (listParentRecord.size() &gt; 0) { 34.for (Record record : listParentRecord) { 35.// 添加所有子级 36.record.set(&quot;childs&quot;, this.getTreeChildRecord(listNotParentRecord, record.getStr(&quot;uuid&quot;))); 37.} 38.} 39.return listParentRecord; 40.} 41. 42./** 43. * 说明方法描述：使list转换为树并根据关键字和节点名称过滤 44. * 45. * @param allRecords 所有节点 46. * @param keywords 要过滤的关键字 47. * @param filterFields 要过滤的字段 48. * @return 49. * @time 2016年5月19日 下午3:27:32 50. * @author yangdong 51. */ 52.public List&lt;Record&gt; useListRecordToTreeByKeywords(List&lt;Record&gt; allRecords, String keywords, String... filterFields) { 53.List&lt;Record&gt; listRecord = new ArrayList&lt;Record&gt;(); 54.Map&lt;String, Record&gt; allRecordMap = new HashMap&lt;String, Record&gt;(); 55.for (Record record : allRecords) { 56.allRecordMap.put(record.getStr(&quot;uuid&quot;), record); 57.} 58.// 遍历allRrecords找出所有的nodeName和关键字keywords相关的数据 59.if (allRecords != null &amp;&amp; allRecords.size() &gt; 0) { 60.if (filterFields.length &gt; 1) { 61.for (Record record : allRecords) { 62.for (String field : filterFields) { 63.// 比较 64.if (record.getStr(field).toLowerCase().indexOf(keywords.toLowerCase()) != -1) { 65.listRecord.add(record); 66.} 67.} 68.} 69.} else { 70.for (Record record : allRecords) { 71.// 比较 72.if (record.getStr(filterFields[0]).toLowerCase().indexOf(keywords.toLowerCase()) != -1) { 73.listRecord.add(record); 74.} 75.} 76.} 77.} 78.// 查找过滤出来的节点和他们的父节点 79.listRecord = this.getSelfAndTheirParentRecord(listRecord, new ArrayList&lt;Record&gt;(), 80. new HashMap&lt;String, Record&gt;(), allRecordMap); 81.// 将过滤出来的数据变成树tree结构 82.listRecord = this.useListRecordToTree(listRecord); 83.return listRecord; 84.} 85. 86./** 87. * 说明方法描述：递归查询子节点 88. * 89. * @param childList 子节点 90. * @param parentUuid 父节点id 91. * @return 92. * @time 2016年5月10日 下午3:29:35 93. * @author yangdong 94. */ 95.private List&lt;Record&gt; getTreeChildRecord(List&lt;Record&gt; childList, String parentUuid) { 96.List&lt;Record&gt; listParentRecord = new ArrayList&lt;Record&gt;(); 97.List&lt;Record&gt; listNotParentRecord = new ArrayList&lt;Record&gt;(); 98.// 遍历tmpList，找出所有的根节点和非根节点 99.if (childList != null &amp;&amp; childList.size() &gt; 0) { 100.for (Record record : childList) { 101.// 对比找出父节点 102.if (StringUtil.equals(record.getStr(&quot;parent_uuid&quot;), parentUuid)) { 103.listParentRecord.add(record); 104.} else { 105.listNotParentRecord.add(record); 106.} 107. 108.} 109.} 110.// 查询子节点 111.if (listParentRecord.size() &gt; 0) { 112.for (Record record : listParentRecord) { 113.// 递归查询子节点 114.record.set(&quot;childs&quot;, getTreeChildRecord(listNotParentRecord, record.getStr(&quot;uuid&quot;))); 115.} 116.} 117.return listParentRecord; 118.} 119. 120./** 121. * 说明方法描述：递归找出本节点和他们的父节点 122. * 123. * @param parentList 根据关键字过滤出来的相关节点的父节点 124. * @param resultList 返回的过滤出来的节点 125. * @param filterRecordMap 已经过滤出来的节点 126. * @param allRecordMap 所有节点 127. * @return 128. * @time 2016年5月19日 上午9:53:56 129. * @author yangdong 130. */ 131.private List&lt;Record&gt; getSelfAndTheirParentRecord(List&lt;Record&gt; parentList, List&lt;Record&gt; resultList, 132. Map&lt;String, Record&gt; filterRecordMap, 133. Map&lt;String, Record&gt; allRecordMap) { 134.// 当父节点为null或者节点数量为0时返回结果，退出递归 135.if (parentList == null || parentList.size() == 0) { 136.return resultList; 137.} 138.// 重新创建父节点集合 139.List&lt;Record&gt; listParentRecord = new ArrayList&lt;Record&gt;(); 140.// 遍历已经过滤出来的节点 141.for (Record record : parentList) { 142. 143.String uuid = record.getStr(&quot;uuid&quot;); 144.String parent_uuid = record.getStr(&quot;parent_uuid&quot;); 145. 146.// 如果已经过滤出来的节点不存在则添加到list中 147.if (!filterRecordMap.containsKey(uuid)) { 148.listParentRecord.add(record);// 添加到父节点中 149.filterRecordMap.put(uuid, record);// 添加到已过滤的map中 150.allRecordMap.remove(uuid);// 移除集合中相应的元素 151.resultList.add(record);// 添加到结果集中 152.} 153. 154.// 找出本节点的父节点并添加到listParentRecord父节点集合中，并移除集合中相应的元素 155.if (StringUtil.isNotBlank(parent_uuid)) { 156.Record parentRecord = allRecordMap.get(parent_uuid); 157.if (parentRecord != null) { 158.listParentRecord.add(parentRecord); 159.allRecordMap.remove(parent_uuid); 160.} 161.} 162. 163.} 164.// 递归调用 165.getSelfAndTheirParentRecord(listParentRecord, resultList, filterRecordMap, allRecordMap); 166. 167.return resultList; 168.} /** * 说明方法描述：递归查询所有权限 * * @param keyword * @param is_deleted * @return * @time 2016年5月10日 下午3:47:50 * @author yangdong */ public List&lt;Record&gt; getRecordByKeywordRecursive(String keyword, String is_deleted) { // 第一步：查询所有的数据 StringBuffer sql = new StringBuffer( &quot; select pa.uuid,pa.parent_uuid,pa.author_code,pa.author_name,pa.is_menu,pa.sort_number,pa.is_enable,pa.menu_icon &quot;); sql.append(&quot; from s_author pa&quot;); List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); sql.append(&quot; where pa.is_deleted=? &quot;); params.add(is_deleted); sql.append(&quot; order by pa.sort_number asc &quot;); List&lt;Record&gt; allRrecords = Db.use(AppConst.DB_DATASOURCE_MAIN).find(sql.toString(), ParamUtil.listToArray(params)); //第二步：将list变为树tree结构 if (StringUtil.isNotBlank(keyword)) { return super.useListRecordToTreeByKeywords(allRrecords, keyword, &quot;author_name&quot;); } else { return super.useListRecordToTree(allRrecords); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决MySQL中mysql5中大数据错误：Packet for query is too large ().]]></title>
    <url>%2F2018%2F01%2F21%2FMysql5%E4%B8%AD%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[报错信息解决MySQL中mysql5中大数据错误：Packet for query is too large (). SEVERE: Servlet.service() for servlet [webs] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.TransientDataAccessResourceException: Hibernate flushing: Could not execute JDBC batch update; SQL [update t_article set (省略部分…)author_id=? where id=?];Packet for query is too large (2048 &gt; 1024). You can change this value on the server by setting the max_allowed_packet’ variable.; nested exception is java.sql.BatchUpdateException: Packet for query is too large (1117260 &gt; 1048576). You can change this value on the server by setting the max_allowed_packet’ variable.] with root cause java.sql.BatchUpdateException: Packet for query is too large (1117260 &gt; 1048576). You can change this value on the server by setting the max_allowed_packet’ variable. 开始以为是相应字段的类型设置不正确，超出了字段的最大范围，网上查询后发现是mysql默认加载的数据文件不超过1M，可以通过更改mysql的配置文件my.cnf（Linux，或windows的my.ini）来更改这一默认值，从而达到插入大数据的目的。 解决方案 MySQL的一个系统参数：max_allowed_packet，其默认值为1048576(1M)，可以先查询一下：show VARIABLES like ‘%max_allowed_packet%’;修改此变量的值：MySQL安装目录下的my.ini文件中的[mysqld]段中的＂max_allowed_packet = 1M＂，如更改为4M(如果没有这行内容，增加一行)，保存，重新启动MySQL服务。现在可以load大于1M的文件了。有时候命令“SET GLOBA Lmax_allowed_packet = 1610241024”无效，需要使用如下命令：set@@max_allowed_packet=510241024 注意MySQL的一个系统参数：max_allowed_packet，其默认值为1048576(1M)，可以先查询一下：show VARIABLES like ‘%max_allowed_packet%’;修改此变量的值：MySQL安装目录下的my.ini文件中的[mysqld]段中的＂max_allowed_packet = 1M＂，如更改为4M(如果没有这行内容，增加一行)，保存，重新启动MySQL服务。现在可以load大于1M的文件了。有时候命令“SET GLOBA Lmax_allowed_packet = 1610241024”无效，需要使用如下命令：set@@max_allowed_packet=510241024]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk1.6和jdk1.7中比较器的问题]]></title>
    <url>%2F2018%2F01%2F21%2Fjdk%E6%AF%94%E8%BE%83%E5%99%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景为了统一线上服务器运行环境，将两台服务器的Tomcat6+JDK6升级到Tomcat7+JDK7，本以为很简单的事情，升级后自己验证也没问题，没想到却悲剧了。升级后，过了半小时运营就找过来反馈问题，部分角色无法登陆系统，由于异常日志没有输出，没有找到问题，无奈回滚。今天我们就来说说JDK6升级到JDK7会遇到的坑。本文为了方便搜索，就直接以异常信息作为文章标题了。 复现回滚后，到测试环境按照线上的权限设置，复现改问题，加上error日志输出，输出了异常，这个异常是在类似如下代码中抛出的： Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 &gt; o2 ? 1 : -1;// 错误的方式 } }); 不修改代码那么问题来了。为什么上面代码在JDK6中运行中无问题.而在JDK7中却会抛异常呢？这是因为JDK7底层的排序算法换了，如果要继续使用JDK6的排序算法，可以在JVM的启动参数中加入如下参数： -Djava.util.Arrays.useLegacyMergeSort=true 这样就会照旧使用JDK6的排序算法，在不能修改代码的情况下，解决这个兼容的问题。 分析在我以前的认知中，高版本的JDK是可以兼容之前的代码的，与同事讨论了一番另加搜索了一番，事实证明，JDK6到JDK7确实存在兼容问题（不兼容列表）。在不兼容列表中我们可以找到关于Collections.sort的不兼容说明，如下： Area: API: Utilities Synopsis: Updated sort behavior for Arrays and Collections may throw an IllegalArgumentException Description: The sorting algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort has been replaced. The new sort implementation may throw an IllegalArgumentException if it detects a Comparable that violates the Comparable contract. The previous implementation silently ignored such a situation. If the previous behavior is desired, you can use the new system property, java.util.Arrays.useLegacyMergeSort, to restore previous mergesort behavior. Nature of Incompatibility: behavioral RFE: 6804124 描述的意思是说，java.util.Arrays.sort(java.util.Collections.sort调用的也是此方法)方法中的排序算法在JDK7中已经被替换了。如果违法了比较的约束新的排序算法也许会抛出llegalArgumentException异常。JDK6中的实现则忽略了这种情况。那么比较的约束是什么呢？看这里，大体如下： sgn(compare(x, y)) == -sgn(compare(y, x)) ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0 compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z 再回过头来看我们开篇有问题的实现： return x y ? 1 : -1; 当x == y时，sgn(compare(x, y)) = -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束，所以在JDK7中抛出了本文标题的异常。 结论那么现在是否可以盖棺定论了，按照上面的分析来看，使用这种比较方式（return x &gt; y ? 1 : -1;），只要集合或数组中有相同的元素，就会抛出本文标题的异常。实则不然，什么情况下抛出异常，还取决于JDK7底层排序算法的实现，也就是大名鼎鼎的TimSort。后面文章会分析TimSort。本文给出一个会引发该异常的Case，以便有心人共同研究，如下： Integer[] array ={0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2, 1, 0, 0, 0, 2, 30, 0, 3}; 在window中，需要在Tomcat中的bin目录里catalina.bat文件中加入这个：在Linux系统中，同样是在bin目录里catalina.sh文件中加入如下：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a系统跳转到b系统伪登录实现]]></title>
    <url>%2F2018%2F01%2F21%2F%E4%BC%AA%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[需求实现点击a系统的舆情，直接跳转到b系统的首页，跳过登陆页面，直接跳转到b系统 a系统页面代码如下： &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a target=&quot;_blank&quot; onclick=&quot;loadInfo();&quot;&gt;舆情&lt;/a&gt; &lt;!-- &lt;a id = &quot;dwadaw&quot; onclick = &quot;&quot;&gt;adwa&lt;/a&gt; --&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function loadInfo() { //alert(1111111111111111111111111); $.getJSON(&quot;http://localhost:8011/jeecg/loginController.do?checkuser&amp;userNames=bigwise&amp;passWords=123456&amp;userKey=D1B5CC2FE46C4CC983C073BCA897935608D926CD32992B5900&amp;statuss=&apos;1&apos;&quot;, function(data) { //$.getJSON(&quot;http://localhost:8011/jeecg/loginController.do?checkuser&amp;userNames=bigwise&amp;passWords=123456&amp;statuss=&apos;1&apos;&quot;, function(data) { $(data).each(function(i, item) { console.log(item);//alert(item); if(item.success == true){ window.location.href=&apos;http://localhost:8011/jeecg/loginController.do?login&apos;; } /* $(&quot;#info&quot;).append( &quot;&lt;div&gt;&quot; + item.id + &quot;&lt;/div&gt;&quot; + &quot;&lt;div&gt;&quot; + item.nickname+ &quot;&lt;/div&gt;&quot; + &quot;&lt;div&gt;&quot; + item.content + &quot;&lt;/div&gt;&lt;hr/&gt;&quot;); */ }); }); } b系统后台代码：在登陆后台代码上加上如下代码： String one = req.getParameter(&quot;statuss&quot;); if(one != null){ String userNames = req.getParameter(&quot;userNames&quot;); String passWords = req.getParameter(&quot;passWords&quot;); String userKey = req.getParameter(&quot;userKey&quot;); user.setPassword(passWords); user.setUserName(userNames); user.setUserKey(userKey); } 即可]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前台页面配置sql连接]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%89%8D%E5%8F%B0%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[###在前台页面配置sql的数据库连接，然后将其数据导入到数据库中，页面上的配置如下图所示 前端页面代码如下：&lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;${ctx}/assets/lib/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function dochange(dbType) { $.get(&quot;${ctx}/console/install/getDbInfo&quot;, { &quot;DbType&quot; : dbType }, function(data) { for (var key in data) { $(&quot;#&quot; + key).val(data[key]); } }) } $(function() { dochange(); $(&quot;#impl&quot;).click(function() { var formData = $(&quot;#form1&quot;).serialize(); console.log(formData); $.post(&quot;${ctx}/console/install/impl&quot;, formData, function(data) { alert(data); }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: #D2D6DE; padding: 50px&quot;&gt; &lt;h1 align=&quot;center&quot;&gt; &lt;b&gt;fsm5安装向导&lt;/b&gt; &lt;/h1&gt; &lt;div style=&quot;width: 750px; height: 400px; margin: 0 auto; background-color: #ffffff;&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-header&quot;&gt; &lt;h3 class=&quot;box-title&quot;&gt;fsm5安装：填写数据库连接信息。&lt;/h3&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;div class=&gt; &lt;h3 class=&quot;box-title&quot;&gt;请在下方填写您的数据库连接信息。如果您不确定，请联系您的服务提供商。&lt;/h3&gt; &lt;/div&gt; &lt;form name=&quot;form1&quot; id=&quot;form1&quot;&gt; &lt;table style=&quot;width:100%&quot;&gt; &lt;tr&gt; &lt;td&gt;选择数据库：&lt;/td&gt; &lt;td&gt;&lt;select size=&quot;1&quot; name=&quot;DbType&quot; id=&quot;DbType&quot; onChange=&quot;dochange(this.value)&quot;&gt; &lt;option value=&quot;mysql&quot;&gt;mysql&lt;/option&gt; &lt;option value=&quot;oracle&quot;&gt;oracle&lt;/option&gt; &lt;option value=&quot;sqlserver&quot;&gt;sqlserver&lt;/option&gt; &lt;option value=&quot;dm&quot;&gt;dm&lt;/option&gt; &lt;/select&gt;&lt;/td&gt; &lt;td&gt;选择你想用的数据库&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数据库驱动：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;Driver&quot; name=&quot;Driver&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;td&gt;您的数据库驱动是？&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数据库连接：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;Url&quot; name=&quot;Url&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;td&gt;您的数据库连接是？&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;User&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;td&gt;您的数据库用户名？&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; id=&quot;Password&quot; name=&quot;Password&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;td&gt;您的数据库密码是？&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;br&gt; &lt;br&gt; &lt;/div&gt; &lt;hr&gt; &lt;!-- /.box-body --&gt; &lt;div id=&quot;footer&quot; style=&quot;padding-right: 5px&quot;&gt; &lt;a class=&quot;you1&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;impl&quot; class=&quot;you&quot; value=&quot;初始化数据&quot; style=&quot;width:80px; height:30px; background-color: #337ab7;color: #ffffff;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 后台代码如下：package com.code.controller; import java.util.HashMap; import java.util.Map; import org.apache.commons.configuration.PropertiesConfiguration; import com.code.core.MyConfig; import com.code.util.SqlImp; import com.jfinal.core.Controller; import com.jfinal.kit.StrKit; public class InstallController extends Controller { public void index() { if(MyConfig.installed){ renderText(&quot;已经初始化完成&quot;); return; } render(&quot;install.html&quot;); } public void getDbInfo() { Map&lt;String, String&gt; dbInfo = new HashMap&lt;String, String&gt;(); try { PropertiesConfiguration myconfig = new PropertiesConfiguration(&quot;myconfig.properties&quot;); String strDbType = getPara(&quot;DbType&quot;); if (StrKit.isBlank(strDbType)) { strDbType = myconfig.getString(&quot;db&quot;); } dbInfo.put(&quot;DbType&quot;, strDbType); dbInfo.put(&quot;Driver&quot;, myconfig.getString(strDbType + &quot;Driver&quot;)); dbInfo.put(&quot;Url&quot;, myconfig.getString(strDbType + &quot;Url&quot;)); dbInfo.put(&quot;User&quot;, myconfig.getString(strDbType + &quot;User&quot;)); dbInfo.put(&quot;Password&quot;, myconfig.getString(strDbType + &quot;Password&quot;)); } catch (Exception e) { e.printStackTrace(); } renderJson(dbInfo); } public void impl() { String msg = &quot;数据库脚本初始化成功，请重启中间件进入系统&quot;; try { PropertiesConfiguration myconfig = new PropertiesConfiguration(&quot;myconfig.properties&quot;); String strDbType = getPara(&quot;DbType&quot;); String strDriver = getPara(&quot;Driver&quot;); String strUrl = getPara(&quot;Url&quot;); String strUser = getPara(&quot;User&quot;); String strPassword = getPara(&quot;Password&quot;); String str = SqlImp.exec(strDbType,strDriver,strUrl,strUser,strPassword); if (StrKit.notBlank(str)) { msg = str; } myconfig.setProperty(&quot;db&quot;, strDbType); myconfig.setProperty(strDbType + &quot;Driver&quot;, strDriver); myconfig.setProperty(strDbType + &quot;Url&quot;, strUrl); myconfig.setProperty(strDbType + &quot;User&quot;, strUser); myconfig.setProperty(strDbType + &quot;Password&quot;, strPassword); myconfig.save(); } catch (Exception e) { msg = &quot;操作失败&quot;; e.printStackTrace(); } renderText(msg); } } 对应的数据库连接如下： db=sqlserver dmDriver = dm.jdbc.driver.DmDriverdmUrl = jdbc:dm://localhost:5236/fsm4jdmUser = fsm4jdmPassword =123456789 sqlserverDriver =net.sourceforge.jtds.jdbc.DriversqlserverUrl =jdbc:jtds:sqlserver://localhost:1433;DatabaseName=fsm5sqlserverUser =sasqlserverPassword =123456 oracleDriver = oracle.jdbc.driver.OracleDriveroracleUrl = jdbc:oracle:thin:@localhost:1521:xeoracleUser = fsm4joraclePassword = fsm4j mysqlDriver = com.mysql.jdbc.DrivermysqlUrl = jdbc:mysql://192.168.5.231/fsm4j?zeroDateTimeBehavior=convertToNullmysqlUser = rootmysqlPassword =password devMode = true]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将标准sql语句导入到数据库中]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%B0%86%E6%A0%87%E5%87%86%E7%9A%84sql%E8%84%9A%E6%9C%AC%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[将转换为标准的sql文件导入到数据库中 /** * 将标准sql脚本导入本地数据库，导入前需清空数据库 * */ public class SqlImp { static Logger logger = Logger.getLogger(SqlImp.class); public static String exec(String db,String driver,String url,String user,String password) { String str = &quot;&quot;; try { String jdbcUrl = url; Class.forName(driver); Connection conn = DriverManager.getConnection(jdbcUrl, user, password); ScriptRunner runner = new ScriptRunner(conn); Writer result = new StringWriter(); PrintWriter printWriter = new PrintWriter(result); // runner.setLogWriter(printWriter); runner.setErrorLogWriter(printWriter); runner.setAutoCommit(true); runner.setStopOnError(false); // 构建流集合 Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;(); InputStream standard = new FileInputStream(PathKit.getWebRootPath() + &quot;/WEB-INF/dbsql/&quot;+db+&quot;.sql&quot;); // InputStream testdata = new // FileInputStream(PathKit.getWebRootPath() + &quot;/doc/testdata.sql&quot;); vector.addElement(standard); // vector.addElement(testdata); Enumeration&lt;InputStream&gt; enu = vector.elements(); // 合并流 SequenceInputStream sis = new SequenceInputStream(enu); InputStreamReader isr = new InputStreamReader(sis, &quot;utf-8&quot;); Reader reader = new BufferedReader(isr); runner.runScript(reader); str = result.toString(); }catch (IOException e) { e.printStackTrace(); }catch (ClassNotFoundException e) { logger.info(e.getMessage()); str=&quot;数据库驱动错误&quot;; }catch (SQLException e) { logger.info(e.getMessage()); str=&quot;数据库连接错误&quot;; } return str; } public static String stringToHexString(String strPart) { String hexString = &quot;&quot;; for (int i = 0; i &lt; strPart.length(); i++) { int ch = (int) strPart.charAt(i); String strHex = Integer.toHexString(ch); hexString = hexString + strHex; } return hexString; } /** * 执行sql文件 * * @return */ public static String exec() { String str = &quot;&quot;; PropertiesConfiguration myconfig; try { myconfig = new PropertiesConfiguration(&quot;myconfig.properties&quot;); String db = myconfig.getString(&quot;db&quot;); String jdbcUrl = myconfig.getString(db + &quot;Url&quot;); exec(db, jdbcUrl, myconfig.getString(db + &quot;Driver&quot;), myconfig.getString(db + &quot;User&quot;), myconfig.getString(db + &quot;Password&quot;)); } catch (ConfigurationException e) { e.printStackTrace(); } return str; } public static void main(String[] args) { MyConfig mc = new MyConfig(); mc.initConsole(); String str = exec(); System.out.println(str); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将java调用百度地址匹配接口获取经纬度坐标]]></title>
    <url>%2F2017%2F11%2F18%2F%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9D%80%E5%8C%B9%E9%85%8D%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BB%8F%E7%BA%AC%E5%BA%A6%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[做项目中经常要调用 百度地图，遇到要根据坐标得到地址名称，或根据名称匹配得到经纬度坐标，所以提取出来写了两个通用方法。需要依赖 json.jar 包。 代码如下： /** * 地址匹配 * @author * */ public class AddressParse { /** * 正向地址匹配接口 * 根据xy获取所在省市县 * @param xy * @return */ public static Map geodecode(String xy){ String sUrl=&quot;http://api.map.baidu.com/geocoder/v2/?ak=8926feb9ef0a93c41c13b6103bf4dfa6&amp;location=&quot;+xy + &quot;&amp;output=json&amp;pois=0&quot;; String address=&quot;&quot;; StringBuffer str = new StringBuffer(); Map resultMap=new HashMap(); try { java.net.URL url = new java.net.URL(sUrl); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(),&quot;utf-8&quot;)); String line; while ((line = in.readLine()) != null) { str.append(line); } in.close(); if (str.equals(&quot;&quot;) || str == null) { System.err.println(&quot;百度服务无返回&quot;); return null; } System.out.println(str.toString()); JSONObject jsonobj = null; try { jsonobj = JSONObject.fromObject(str.toString()); JSONObject result = jsonobj.getJSONObject(&quot;result&quot;);// 获取对象 JSONObject addressComponent = result .getJSONObject(&quot;addressComponent&quot;); String province = addressComponent .getString(&quot;province&quot;); resultMap.put(&quot;province&quot;,province); String city = addressComponent.getString(&quot;city&quot;); resultMap.put(&quot;city&quot;,city); String district = addressComponent .getString(&quot;district&quot;); resultMap.put(&quot;district&quot;,district); } catch (Exception e) { e.printStackTrace(); System.out.println(&quot;此坐标获取不到省份：&quot;+xy); } } catch (Exception e) { e.printStackTrace(); } return resultMap; } /** * 逆向匹配接口 * 根据地址名称，匹配得到经纬度坐标 * @param addr * @return */ public static String geocode(String addr){ String xyStr=&quot;&quot;; addr=URLEncoder.encode(addr); StringBuffer str = new StringBuffer(); String lng=&quot;&quot;; String lat=&quot;&quot;; try { //System.out.println(&quot;http://api.map.baidu.com/geocoder?address=&quot;+addr+&quot;&amp;output=json&quot;); String sUrl=&quot;http://api.map.baidu.com/geocoder/v2/?address=&quot;+addr+&quot;&amp;&amp;output=json&amp;ak=SgntTWnUw65ysdPSghbs27noTxOuK88O&quot;; java.net.URL url = new java.net.URL(sUrl); //java.net.URL url = new java.net.URL(&quot;http://api.map.baidu.com/?qt=gc&amp;wd=&quot;+addr+&quot;&amp;cn=%E5%85%A8%E5%9B%BD&amp;ie=utf-8&amp;oue=0&amp;res=api&amp;callback=BMap._rd._cbk96117&quot;); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String line; while ((line = in.readLine()) != null) { str.append(line); } in.close(); JSONObject dataJson=null; dataJson =JSONObject.fromObject(str.toString()); JSONObject result=dataJson.getJSONObject(&quot;result&quot;); JSONObject location=result.getJSONObject(&quot;location&quot;); lng =location.getDouble(&quot;lng&quot;)+&quot;&quot;; lat =location.getDouble(&quot;lat&quot;)+&quot;&quot;; xyStr= lng+&quot; &quot;+lat; } catch (Exception e) { lng=&quot;&quot;; lat=&quot;&quot;; } return xyStr; } public static void main(String [] args){ String xy = AddressParse.geocode(&quot;成都市成华区建设路颐和家园7栋2801&quot;); System.out.println(xy); Map address = AddressParse.geodecode(&quot;40.033534,116.313289&quot;); System.out.println(address); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理sql为标准sql]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%B0%86sql%E5%A4%84%E7%90%86%E4%B8%BA%E6%A0%87%E5%87%86%E7%9A%84sql%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[将mysql数据库使用navcat导出后处理为标准的sql脚本 /** * 将navicat导出的mysql数据库脚本处理为标准脚本 */ public class StandardSql { public static void make() { try { String str = FileUtils.readFileToString(new File(PathKit.getWebRootPath() + &quot;/src/main/webapp/WEB-INF/dbsql/fsm5.sql&quot;), &quot;utf-8&quot;); str = str.replaceAll(&quot;`&quot;, &quot;&quot;).replaceAll(&quot;([ \t]+)longtext([ \t,]*)&quot;, &quot; clob $2&quot;).replaceAll(&quot;ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;, &quot;&quot;) .replaceAll(&quot;DROP TABLE IF EXISTS ([^;]*);&quot;, &quot;-- DROP TABLE $1&quot;).replaceAll(&quot;SET FOREIGN_KEY_CHECKS=0;&quot;, &quot;&quot;).replaceAll(&quot;/\\*([^\\*]+)\\*/&quot;, &quot;&quot;); //视图处理 str=str.replaceAll(&quot;DROP VIEW IF EXISTS ([^;]*);&quot;, &quot;-- DROP VIEW $1&quot;).replaceAll(&quot;ALGORITHM=UNDEFINED DEFINER=root@% SQL SECURITY DEFINER &quot;, &quot;&quot;); // 注释处理 str = str.replaceAll(&quot;COMMENT=&apos;([^&apos;]+)&apos;;&quot;, &quot;;\r\n -- $1&quot;).replaceAll(&quot;COMMENT &apos;([^&apos;]+)&apos;,&quot;, &quot;, -- $1&quot;); // 处理整形 str = str.replaceAll(&quot; int(\\(\\d+\\)) &quot;, &quot; int &quot;); //替换\r\n\&quot; str = str.replaceAll(&quot;\\x5c\\x72&quot;, &quot;\&quot;&quot;).replaceAll(&quot;\\x5c\\x6e&quot;, &quot;&quot;).replaceAll(&quot;\\x5c\\x22&quot;, &quot;\&quot;&quot;); System.out.println(str); String mysql=str.replaceAll(&quot;([ \t]+)clob([ \t,]*)&quot;, &quot; longtext $2&quot;); FileUtils.writeStringToFile(new File(PathKit.getWebRootPath() + &quot;/src/main/webapp/WEB-INF/dbsql/mysql.sql&quot;), mysql, &quot;utf-8&quot;); String oracle=str.replaceAll(&quot;\\x5c\\x27&quot;, &quot;\\&apos;\\&apos;&quot;); FileUtils.writeStringToFile(new File(PathKit.getWebRootPath() + &quot;/src/main/webapp/WEB-INF/dbsql/oracle.sql&quot;), oracle, &quot;utf-8&quot;); String sqlserver=str.replaceAll(&quot;([ \t]+)clob([ \t,]*)&quot;, &quot; text $2&quot;).replaceAll(&quot;\\x5c\\x27&quot;, &quot;\\&apos;\\&apos;&quot;); FileUtils.writeStringToFile(new File(PathKit.getWebRootPath() + &quot;/src/main/webapp/WEB-INF/dbsql/sqlserver.sql&quot;), sqlserver, &quot;utf-8&quot;); String dm=str.replaceAll(&quot;\\x5c\\x27&quot;, &quot;\\&apos;\\&apos;&quot;); FileUtils.writeStringToFile(new File(PathKit.getWebRootPath() + &quot;/src/main/webapp/WEB-INF/dbsql/dm.sql&quot;), dm, &quot;utf-8&quot;); } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] args) { make(); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JFinal和DataTasbles实现增删改]]></title>
    <url>%2F2017%2F11%2F18%2Fdatatables%E5%A2%9E%E5%88%A0%E6%94%B9%2F</url>
    <content type="text"><![CDATA[下面记录下个人在使用过程中的一些难点，顺带一些没有解决的问题。先看下插件的页面效果：如果仅仅作为表格的载体，其实有很多插件可以选择。我更看重的是它的编辑功能，后台为维护更多的是对单跳数据进行操作，具体场景是客服和客户 1V1的交流，而dataTables对于单条数据的编辑，是相当不错的，具体来说，采用bootstrap的模态窗口（插件自动生成）实现了修改功能。 对于开发人员来说，省去了另写编辑页面的繁琐。 话不多说，下面慢慢粘代码以及效果图。 对于一个和后台交互的插件，最重要其实就两件事情，需要什么样的数据格式，提交给后台的又是怎样的数据格式，搞清楚这两点，其实就没什么了。 dataTables支持很多数据源，官方有详细介绍，项目采用了轻量级的json数据进行传输，以下是插件填充表格时所需的数据格式： 对于增删改查，dataTable默认传给后台的数据相当蛋疼，这里费了不少心思，最后重新封装了下数据格式，先看一下默认的数据格式： 想要看懂上面的数据，还需要知道一个知识点，如果想使用dataTables的编辑功能，返回数据中，需要包括”DT_RowId”这个键，这个键值对需要放在每一行的数据中，充当表格的主键，当然，重复也没关系，这就是让人困惑的地方； 有了这个知识点，在看编辑数据时，默认的数据格式，这些都是键值对，对于键的命名，action表示操作行为，包括 remove,edit,create三种键值，支持自定义，详细的可以参考官方文档；剩下的便是每个单元格的表示，“data[row1] [accountId]”中，data是固定的，row1是选中行DT_RowId的值，accountId是选中行列的别称，关于列名和json数据源 键名的匹配，以下会有详细代码。 看懂这个之后，再去思考后台如何拿数据，后台不可能去遍历request中的所有参数，所以比较好的方法就是在前台二次封装这些数据，通过对json数据的重新封装，即可，以下是个人的封装方法：javaScript代码： ajax: { url:”/charge-manage/individualMember/edit”, data:function(data){ var result={}; for(var i in data.data){ var result=data.data[i]; result.DT_RowId=i; result.action=data.action; console.log(result); } return result; }, }, 经过这样的封装，参数类型如下： 这样后台就方便拿参数进行操作了。 解决了数据流向问题，在看页面本身的问题，表格列名如何与数据源匹配，这个比较简单，代码如下：js代码如下： $(‘#member’).DataTable( { dom: “Bfrtip”, ajax:”/charge-manage/individualMember/getMember?”+”phoneNum=”+phoneNum, columns:[{data:”memberCode”}, {data:”accountId”}, {data:”phoneNum”}, {data:”password”}, {data:”lastLoginTime”} ], select:true, buttons: [ { extend: “create”, editor: editor }, { extend: “edit”, editor: editor }, { extend: “remove”, editor: editor }] } ); columns集合中的顺序，对应表格列的顺序，data的值，对应json数据源中的键；以下是表格的实际图形： 编辑操作有自己的操作对象，也就是上面buttons栏引用的，代码如下：js代码如下： var editor = new $.fn.dataTable.Editor( { ajax: { url:”/charge-manage/individualMember/edit”, data:function(data){ var result={}; for(var i in data.data){ var result=data.data[i]; result.DT_RowId=i; result.action=data.action; console.log(result); } return result; }, }, fields: [{ label: &quot;会员编码:&quot;, name: &quot;memberCode&quot; }, { label: &quot;账户编码:&quot;, name: &quot;accountId&quot; },{ label: &quot;手机号:&quot;, name: &quot;phoneNum&quot; },{ label: &quot;密码:&quot;, name: &quot;password&quot; },{ label: &quot;最后登录时间:&quot;, name: &quot;lastLoginTime&quot; }], table: &quot;#member&quot; }); fields集合中，label值是模态窗口对应的名称，细心的同学可以看到加了冒号，name对应向后台传入参数的键名。下面是该模态的实际图片，再次强调，这玩意是自动生成的]]></content>
      <categories>
        <category>jfinal</category>
      </categories>
      <tags>
        <tag>jfinal、datatables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JFinal和datatales-editor增删改]]></title>
    <url>%2F2017%2F11%2F18%2Fjfinal%E5%92%8Cdatatables-editor%2F</url>
    <content type="text"><![CDATA[页面js代码如下： editor = new $.fn.dataTable.Editor( { ajax: { url:&quot;${ctx}/console/job/dtAction?job.orgID=&quot;+orgID, data:function(data){ var result = {}; for(var i in data.data){ //封装json的格式 var result=data.data[i]; result.DT_Rowid=i; result.action=data.action; console.log(result); $.each(result,function (index, value) { //console.log(index); if(index!=&quot;action&quot; &amp;&amp; index!=&quot;DT_Rowid&quot;){ modifyJosnKey(result,index,&quot;job.&quot;+index); } }) } return result; }, }, table: &quot;#example&quot;, idSrc:&quot;id&quot;, fields: [ { label: &quot;主键&quot;, name: &quot;id&quot;, type: &quot;hidden&quot;, }, { label: &quot;岗位名称&quot;, name: &quot;jobname&quot; }, { label: &quot;岗位描述&quot;, name: &quot;jobdesc&quot;, },{ label: &quot;排序&quot;, name: &quot;sortid&quot;, } ], i18n: { create: { button: &quot;新建&quot;, title: &quot;新建&quot;, submit: &quot;保存&quot; }, edit: { button: &quot;编辑&quot;, title: &quot;编辑&quot;, submit: &quot;保存&quot; }, remove: { button: &quot;删除&quot;, title: &quot;删除&quot;, submit: &quot;删除&quot;, confirm: { _: &quot;您是不是一定希望删除%d行吗?&quot;, 1: &quot;您是不是一定希望删除1行吗?&quot; } }, error: { system: &quot;发生错误,请联系管理员&quot; }, datetime: { previous: &apos;上一个&apos;, next: &apos;下一个&apos;, months: [ &apos;一月&apos;, &apos;二月&apos;, &apos;三月&apos;, &apos;四月&apos;, &apos;五月&apos;, &apos;六月&apos;, &apos;七月&apos;, &apos;八月&apos;, &apos;九月&apos;, &apos;十月&apos;, &apos;十一月&apos;, &apos;十二月&apos; ], weekdays: [ &apos;周一&apos;, &apos;周二&apos;, &apos;周三&apos;, &apos;周四&apos;, &apos;周五&apos;, &apos;周六&apos;, &apos;周日&apos; ] } } } ); table = $(&apos;#example&apos;).DataTable( { language: { &quot;sProcessing&quot;: &quot;处理中...&quot;, &quot;sLengthMenu&quot;: &quot;显示 _MENU_ 项结果&quot;, &quot;sZeroRecords&quot;: &quot;没有匹配结果&quot;, &quot;sInfo&quot;: &quot;显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项&quot;, &quot;sInfoEmpty&quot;: &quot;显示第 0 至 0 项结果，共 0 项&quot;, &quot;sInfoFiltered&quot;: &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;sInfoPostFix&quot;: &quot;&quot;, &quot;sEmptyTable&quot;: &quot;表中数据为空&quot;, &quot;sLoadingRecords&quot;: &quot;载入中...&quot;, &quot;sInfoThousands&quot;: &quot;,&quot;, &quot;oPaginate&quot;: { &quot;sFirst&quot;: &quot;首页&quot;, &quot;sPrevious&quot;: &quot;上页&quot;, &quot;sNext&quot;: &quot;下页&quot;, &quot;sLast&quot;: &quot;末页&quot; }, &quot;oAria&quot;: { &quot;sSortAscending&quot;: &quot;: 以升序排列此列&quot;, &quot;sSortDescending&quot;: &quot;: 以降序排列此列&quot; } }, searching:false, dom: &apos;&lt;&quot;dt-panelmenu clearfix&quot;Bfr&gt;t&lt;&quot;dt-panelfooter clearfix&quot;ip&gt;&apos;, ajax: &quot;${ctx}/console/job/dtAction?orgID=&quot;+orgID, columns: [ { data: &quot;jobname&quot;, className: &quot;center&quot; }, { data: &quot;jobdesc&quot;, className: &quot;center&quot; }, { data: &quot;updatetime&quot;, className: &quot;center&quot; } ], select: true, buttons: [ { extend: &quot;create&quot;, editor: editor }, { extend: &quot;edit&quot;, editor: editor }, { extend: &quot;remove&quot;, editor: editor } ] } ); $(&quot;#tree&quot;).fancytree({ source:${orgs}, icons: false, // Display node icons. clickFolderMode: 2, // 1:activate, 2:expand, 3:activate and expand, 4:activate (dblclick expands) activate: function(event, data) { orgID=data.node.data.id; //console.log(orgID); //console.log(table); //console.log(table.context[0]._editor.s.ajax.url); table.context[0]._editor.s.ajax.url=&quot;${ctx}/console/job/dtAction?job.orgID=&quot;+orgID; table.ajax.url(&quot;${ctx}/console/job/dtAction?orgID=&quot;+orgID).load();//再次加载 } }); 后台java代码如下：public void dtAction() { String action = getPara(&quot;action&quot;, &quot;&quot;); switch (action) { case &quot;create&quot;: Job job = getModel(Job.class); User user = getSessionAttr(&quot;User&quot;); job.set(&quot;insertuserid&quot;, user.getStr(&quot;username&quot;)); job.set(&quot;updateuserid&quot;, user.getStr(&quot;username&quot;)); service.save(job); JSONObject json = new JSONObject(); json.put(&quot;data&quot;, job); //Map map1 = new HashMap(); //map1.put(&quot;data&quot;, job); renderJson(json); break; case &quot;edit&quot;: Job job1 = getModel(Job.class); service.update(job1); Map map2 = new HashMap(); map2.put(&quot;data&quot;, job1); renderJson(map2); break; case &quot;remove&quot;: Job job2 = getModel(Job.class); job2.delete(); renderJson(); break; default: String orgID = getPara(&quot;orgID&quot;); List&lt;Job&gt; jobs = Job.dao.find(&quot;select * from t_job where orgid=?&quot;, orgID); Map map = new HashMap(); map.put(&quot;data&quot;, jobs); renderJson(map); break; } return; }]]></content>
      <categories>
        <category>jfinal</category>
      </categories>
      <tags>
        <tag>jfinal、datatables-editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乱码工具判断工具]]></title>
    <url>%2F2017%2F11%2F03%2F%E4%B9%B1%E7%A0%81%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[乱码，指的是“由于本地计算机在用文本编辑器打开源文件时，使用了不相应字符集而造成部分或所有字符无法被阅读的一系列字符。”，造成其结果的原因是多种多样的。 乱码工具类代码如下：import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @author * @version * 说明 判断中文字符串是否乱码 */ public class ChineseUtil { /** * @author mo * @version * 说明 判断是否是中文 */ private static boolean isChinese(char c) { Character.UnicodeBlock ub = Character.UnicodeBlock.of(c); if (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) { return true; } return false; } /** * @author mo * @version * 说明 判断是否乱码 */ public static boolean isMessyCode(String strName) { Pattern p = Pattern.compile(&quot;\\s*|\t*|\r*|\n*&quot;); Matcher m = p.matcher(strName); String after = m.replaceAll(&quot;&quot;); String temp = after.replaceAll(&quot;\\p{P}&quot;, &quot;&quot;); char[] ch = temp.trim().toCharArray(); float chLength = 0 ; float count = 0; for (int i = 0; i &lt; ch.length; i++) { char c = ch[i]; if (!Character.isLetterOrDigit(c)) { if (!isChinese(c)) { count = count + 1; } chLength++; } } float result = count / chLength ; if (result &gt; 0.4) { return true; } else { return false; } } } 将上面的工具类放入带到项目中，在需要引用的项目中引入这个工具类即可 String zgbm = request.getParameter(&quot;zgbm&quot;); if(ChineseUtil.isMessyCode(zgbm)){ try { zgbm = new String(zgbm.getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;); } catch (UnsupportedEncodingException e) { // TODO Auto-generated catch block e.printStackTrace(); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码云和github公钥的配置]]></title>
    <url>%2F2017%2F11%2F03%2F%E7%A0%81%E4%BA%91%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[用户名和邮箱地址的使用用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。每次commit都会用用户名和邮箱纪录。github的contributions统计就是按邮箱来统计的 查看用户名和邮箱的地址$ git config user.name $ git config user.email 设置用户名和邮箱地址$ git config --global user.name &quot;username&quot; $ git config --global user.email &quot;email&quot; 生成sshKey在git命令行中，输入命令： cd ~/.ssh，来检测是否生成过key,没有生成过key，会有相关信息提示；然后输入命令： ssh-keygen -t rsa -C “邮箱地址”，按下回车键；然后根据返回的信息，找到.ssh目录下的两个文件； cat ~/.ssh/id_rsa.pub # ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 添加后在终端中输入ssh -T git@gitee.com 若返回 Welcome to Gitee.com, yourname! 则代表添加成功 github添加是同样的流程]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>ssh公钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装]]></title>
    <url>%2F2017%2F11%2F02%2FNodejs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Node.js简介简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 下载Node.js打开官网下载链接:https://nodejs.org/en/download/ 开始安装1、下载完成后，双击“node-v6.9.2-x64.msi”，开始安装Node.js2、点击Next按钮3、勾选复选框，点击【Next】按钮4、修改好目录后，点击【Next】按钮5、安装完后点击【Finish】按钮完成安装6、至此Node.js已经安装完成，可以先进行下简单的测试安装是否成功了，后面还要进行环境配置在键盘按下【win+R】键，输入cmd，然后回车，打开cmd窗口]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo、node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客]]></title>
    <url>%2F2017%2F11%2F02%2FMo%2F</url>
    <content type="text"><![CDATA[我的第一篇个人博客 欢迎来到我的个人小屋，以后会不定时更新博客]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>死肥宅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+码云搭建个人博客]]></title>
    <url>%2F2017%2F11%2F02%2Fhexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[使用工具介绍1、码云 Pages：码云 Pages 是一个免费的静态网页托管服务，您可以使用码云 Pages 托管博客、项目官网等静态网页。这样就不用购买服务器和域名了，如果您使用过 Github Pages 那么您会很快上手使用码云的Pages服务。这里使用码云上的Pages 而不是用Github Pages，主要原因就是在国内没有VPN的话。。。你懂得！还有就是支持国产！链接：https://git.oschina.net/2、Hexo：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。使用者只需要专注于写博客而不需要关注网站是如何生成的。而且还有丰富的博客主题可以选择！链接：https://hexo.io/zh-cn/（ps：这是国外网站，翻墙吧少年，需要自由门 翻墙软件可以在博客中联系我哦） 搭建环境Node.js安装 参考：http://www.runoob.com/nodejs/nodejs-install-setup.html（ps：如果没有VPN的用户最好切换一下npm的源，不然后续的步骤可能会让你想砸电脑，安装完后，在命令窗口执行下面代码） npm config set registry http://registry.cnpmjs.org #切换npm为淘宝镜像 Git安装 参考http://www.runoob.com/git/git-install-setup.html Hexo安装。（ ps：安装完Node.js和Git之后不需要配置些什么，只需要安装成功就是了，如果想明白原理的话可以深入的学习。） 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。打开命令窗口输入下面代码： npm install -g hexo-cli 安装成功后输入hexo 如果得到下面这个结果，恭喜你！安装成功！ Hexo的常用命令说明： 参考：https://hexo.io/zh-cn/docs/commands.html 本地运行Hexo安装 Hexo 完成后，请依次执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。将 替换成项目存放的文件夹目录， hexo init &lt;folder&gt; cd &lt;folder&gt; npm install hexo generate 新建完成后，指定文件夹的目录如下： 进行到这步后就可以先在本地运行下，看看效果了。执行下面命令： cd &lt;folder&gt; #切换到项目目录下 npm install #install before start blogging hexo server #运行本地服务 浏览器输入http://localhost:4000就可以看到效果。如下： 修改Hexo的主题当然，上面运行的只是Hexo官方默认的主题配置效果，想要个性一点？，下面我们就将他改造成自己想要的个性主题。 Hexo的主题都是一些前端民间高手写的模版，可以在官方收录的主题中去挑选：https://hexo.io/themes/ 看上一个主题后点击下图位置，进入下载主题文件。如下图： 主题下载完成后，将主题文件解压到Hexo项目的thems文件夹下面（ps:我这里的项目目录是在桌面的Hexo文件夹里面。） 接下来就是修改Hexo的配置文件_config.yml，将里面theme 对应的值改为之前下载的主题的文件夹名字，本文里面下载的主题文件夹名字为hexo-theme-smackdown-master。 注意：这里“：”后面必须要有一个空格，而且这个空格要在英文输入法下，不然会报一些稀奇古怪的错。 按照之前步骤本地重新运行后，如下图： 关于Hexo中_config.yml 文件的其他配置，大家可以参考官方的文档，这里就不多赘述了： 文档链接 https://hexo.io/zh-cn/docs/configuration.html 下载的每个主题中，有一个配置文件，名字也叫_config.yml，这里大家千万不要和之前Hexo根目录下的_config.yml搞混淆了，这里面配置的主要是些与主题相关的东西，比如一些文章阅读量，多说插件，cnzz站长工具等等的配置信息。一般里面也都有注释，这里就不赘述了，不懂得可以在我的博客问我。 一些主题在GitHub上面也都有主题安装的一些文档，写的都很详细。推荐一个主题的文档，结合官方的文档看完之后，基本上也就明白了。 推荐一个主题的文档https://github.com/yscoder/hexo-theme-indigo/wiki 编写博客文章如果你使用过MarkDown 来写博客文章的话，接下来就简单多了，没使用过也没关系，推荐大家一个编辑工具马克飞象 链接：https://maxiang.io/，在编辑器里面写好文章后，复制或另存为.md文件, 与普通的.md文件不同 要在文件开头添加下面代码 title: #文章标题 date: #文章日期 tags: #文章标签 categories: #文章分类 --- 在.md文件的开头添加上面代码，是为了让Hexo框架在生成网页的时候，设置相应的参数。例如下图所示： 将写好的.md文件放入Hexo项目的source 目录下的_posts 文件夹中，可以看到里面有个hello-world.md 文件，这就是默认的文章。 重新在本地启动项目，访问就可以看到之前添加的文章。 生成静态Html文件现在只能在本地启动项目然后通过本地地址访问博客网站，下面我们就可以利用Hexo生成静态Html，很简单，只需要在命令窗口执行下面代码： cd &lt;folder&gt; #切换到项目目录下 hexo generate #生成静态文件到项目根目录的public文件夹中 发布静态Html文件到码云 Pages上 注册一个码云帐号，并创建一个项目。如下图： 创建完项目后得到项目的Https的地址后面要用。地址获取如下图 这里借用一个插件来帮助我们完成代码上传的工作，安装 hexo-deployer-git。安装代码如下 npm install hexo-deployer-git --save#把public里面生成的文件推上到码云上。 配置项目根目录_config.yml 文件，修改deploy 的值，如下图： 修改完后在命令窗口执行下面命令： cd #切换到项目目录下 hexo deploy #一键部署功能 之后会弹出一个对话框，输入码云的帐号密码。 部署成功之后，登录码云，查看之前创建的项目中出现了本地项目中public 文件夹中的文件，这时候代表之前的部署是成功的。 然后如下图，启动码云的pages功能： 访问链接 这时候就看到之前和本地启动一样的效果了。博客部署完成，在这之后，只需要每次用马克飞象写好文章后，放入Hexo项目的source 目录下的_posts 文件夹中，在按照之前步骤更新博客就OK了。还可以随时切换博客的主题哦！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[创建一个文件$ hexo new “My New Post” 运行本地服务$ hexo server 生成静态文件$ hexo generate 部署到服务器$ hexo deploy]]></content>
  </entry>
</search>
